
	=====================================================

@(#)		    OKAMI SHELL - KOMPATIBILITéT

	=====================================================
			Stand: 15.8.92


	BITTE ERST DIE DATEIN README UND OKAMI.DOC LESEN!


Diese Datei vermerkt alle énderungen der Shell, die im weitesten Sinne zu
InkompatibilitÑt zu Ñlteren Versionen fÅhren kînnen. Zu jeder énderung ist
ein Datum angegeben. Es bedeutet, daû alle nach diesem Datum erstellten Ver-
sionen der Shell in dem betreffenden Punkt zu allen vor diesem Datum erstell-
ten Versionen inkompatibel sind bzw. sich anders verhalten, was Anpassungen
an Shellscripts o.Ñ. notwendig macht. Das Erstellungsdatum einer Shell kann
durch Eingabe von "ver -c" ermittelt werden.


			========
@(#)			15.11.90
			========

Das Kommando grep hat bisher nur feste Strings ohne RÅcksicht auf Wildcards
gesucht und entsprach daher dem Unix-fgrep. Ab jetzt gibt es fgrep fÅr die
Suche nach festen Strings und grep, das erweiterte Wildcards berÅcksichtigt.
Shellscripts, die grep zum Suchen von Strings, die Wildcards (Sterne, Frage-
zeichen und eckige Klammern) beinhalten, benutzen, sollten statt grep fgrep
benutzen. Die notwendigen énderungen beschrÑnken sich also auf das HinzufÅgen
des "f".


			========
@(#)			23.11.90
			========

Ab diesem Tag betrachtet die Shell das doppelte AnfÅhrungszeichen (") als
Gruppierungssymbol, was sie in den vorigen Versionen nicht getan hat. Das
hat folgende Konsequenzen:

* Das doppelte AnfÅhrungszeichen muû, wenn es ausgegeben werden soll, mit
  einem davorstehenden Dach gequotet werden. Beispiel: das Kommando
  	echo 3.5"-Diskette
  erzeugte in frÅheren Versionen die Ausgabe 3.5"-Diskette. In der neueren
  Version muû es heiûen:
  	echo 3.5^"-Diskette
  ABHILFE: vor jedes AnfÅhrungszeichen ein Dach setzen.

* Wenn mit dem Fluchtsymbol (^) Steuerzeichen in eine Eingabezeile aufgenommen
  werden, mÅssen diese ebenfalls in doppelten AnfÅhrungszeichen stehen, da sie
  sonst als Wort-Trennzeichen gelten. Beispiel: in
  	echo hallo ^n wie gehts
  ist das Zeilenend-Zeichen (^n) ein Worttrenner und wird daher nicht wie in
  den Ñlteren Versionen als Zeilenvorschub ausgegeben.
  ABHILFE: solche FÑlle in doppelte AnfÅhrungszeichen setzen:
  	echo "hallo ^n wie gehts"

* Mehrere hintereinanderstehende Whitespace-Zeichen werden zu einem Leerzeichen
  zusammengefaût, wenn sie nicht in doppelten AnfÅhrungszeichen stehen. Die
  Ñlteren Versionen der Shell taten das nicht. Beispiel:
  	echo a       b          c
  erzeugte in frÅheren Versionen die Ausgabe
  	a       b          c
  , in der aktuellen Version jedoch
  	a b c
  . Das gilt auch fÅr die Deklaration von Shellfunktionen.
  ABHILFE: auch hier in doppelte AnfÅhrungszeichen setzen:
  	echo "a        b          c"




			========
@(#)			27.12.90
			========

Die Umleitung der Ein- und Ausgabe erfolgt ab jetzt vollstÑndig auf Gemdos-
Ebene mit Hilfe der Funktion Fforce. In allen Ñlteren Versionen wurde die
Umleitung nur von der Shell selber durchgefÅhrt.
Der Vorteil der neuen Lîsung ist
1) daû sich jetzt alle externen Programme umleiten lassen, die ihre Ein- und
   Ausgabe Åber Gemdos abwickeln, und
2) daû sich auch externe Programme, die in Shellscripts stehen, zusammen mit
   den Shellscripts umleiten lassen, was vorher nicht mîglich war.

Bedauerlicherweise ergeben sich dadurch auch zwei Nachteile:

*) Wenn ein Kommando eine Tastatureingabe entgegennimmt, wird das Echo der
   Tasten zur Standardausgabe geschrieben. Wenn diese dabei umgeleitet wird,
   kommt das Tastenecho nicht auf den Bildschirm, sondern mit in die Umlei-
   tung. Beispiel: "cat >datei.txt" diente vorher dazu, die Tastatureingabe
   in die Datei datei.txt umzuleiten. Jetzt kommt allerdings auch das Tasten-
   echo in diese Datei.
   ABHILFE: Keine, dieses Problem ist bis jetzt nicht lîsbar.

*) Das Betriebssystem stellt keine Standard-Fehlerausgabe zur VerfÅgung, da es
   die reichlich starre Organisation der "Standard-File-Handles" von MS-DOS
   Åbernommen hat. Es gibt also eine Standard-Eingabe, eine Standard-Ausgabe,
   eine Standard-serielle Schnittstelle usw. Unter Unix wird File-Deskriptor
   Nr. 2 fÅr Fehlerausgaben benutzt, diese werden mit "2>" umgeleitet. Um
   dazu konform zu bleiben, benutzt die Okami-Shell ebenfalls File-Deskriptor
   Nr. 2 fÅr die Fehlerausgaben. Dies ist aber normalerweise die serielle
   Schnittstelle. Die Okami-Shell biegt also zu Beginn alle Ausgaben, die auf
   die Standard-serielle Schnittstelle gehen sollten, auf die Standard-Ausgabe
   um. Das ist nicht allzu schlimm, da Programme, die diese Schnittstelle be-
   nutzen, das sowieso Åber die nicht umleitbaren Xbios-Funktionen tun sollten. 
   Es ist aber aus einem anderen Grund schlimm: die serielle Schnittstelle
   wurde bisher als NULL-GerÑt benutzt. (Ein richtiges Null-GerÑt hat man von
   MS-DOS natÅrlich nicht Åbernommen.) Diese Mîglichkeit fÑllt jetzt natÅrlich
   weg, denn "rm datei 2>NULL:", womit die Fehlerausgabe von rm zum Null-GerÑt
   umgeleitet werden soll, schickt bei NULL=AUX: die Fehlerausgabe Åber die
   serielle Schnittstelle (die auf den Bildschirm umgebogen wurde) genau
   dahin, wo sie nicht hinsoll, nÑmlich auf den Bildschirm.
   Um dieses Problem zu umgehen, lautet die Defaulteinstellung von NULL ab
   jetzt PRN:, es wird also die paralelle Schnittstelle benutzt. Wer hier
   einen Drucker angeschlossen hat, dem bringt das natÅrlich nicht allzu viel.
   ABHILFE: wer keinen Drucker hat, kann NULL auf PRN: stehen lassen.
   Wer wohl einen Drucker hat, sollte NULL auf eine Datei z.B. auf der Ram-
   disk einstellen, z.B. durch die Zeile
   	NULL=$PIPDIR/nullfile
   im Profile.


			======
@(#)			2.2.91
			======

Alle Funktionen, die direkt auf den Bildschirmspeicher zugreifen, arbeiten
von jetzt an mit der logischen (Logbase) anstelle mit der physikalischen
(Physbase) Bildschirmadresse. Diese sind normalerweise beide gleich, aber
die logische Adresse ist zuverlÑssiger, und die Benutzung der physikalischen
Adresse kann zu eigenartigen Effekten fÅhren, wie ich bei der Arbeit am
Okami-Font-Editor festgestellt habe.
Betroffen sind die Funktionen:
	fsel
	getscr
	putscr
sowie die Anzeige der Fileselect-Box in der Tastatureingabe mit Ctrl-F.
Dadurch sollte der eigenartige Effekt, daû putscr einen Bildschirm nicht
oder nicht vollstÑndig wiederherstellt, behoben sein.
Probleme gibt es hîchstens mit Programmen, die logische und physikalische
Adresse auf verschiedene Werte einstellen, z.B. um auf einen Bildschirm zu
zeichnen, wÑhrend ein anderer angezeigt wird. Das ist aber sehr unwahrschein-
lich.

			=======
@(#)			16.2.91
			=======

Das Ausgabeformat von ls wurde z.T. geÑndert. Ab jetzt gibt ls immer relative
Dateinamen aus (frÅher wurden nur die Basisnamen ausgegeben). Beispiel:
"ls ../*.c" lieferte frÅher

	sh.c
	cmds.c
	utl.c

und liefer jetzt

	..\sh.c
	..\cmds.c
	..\utl.c

Daraus folgt, daû die Ausgabe eines Dateinamens nicht immer genau 14 Zeichen
(incl. Leerzeichen am Ende) lang ist, sondern beliebig variiert. Die spalten-
weise Ausgabe mit ls -C paût sich automatisch der DateinamenlÑnge an.
Programme, die auf das bisherige Ausgabeformat rechnen, mÅssen angepaût werden,
wenn Dateilisten von anderen als dem aktuellen Directory verlangt werden.
Eine Mîglichkeit ist das Pipen der ls-Ausgabe zu dem basename-Kommando:
	ls | xargs basename
Dies funktioniert allerdings nicht mit ls -C. Um Probleme mit den Dateityp-
merkern [] (Directory) und <> (ausfÅhrbar) zu vermeiden, sollte hier auch
ls -k benutzt werden.


			======
@(#)			1.3.91
			======

FÅr den Pfad, auf dem Hilfsdateien u.Ñ. liegen, gibt es jetzt eine neue Shell-
variable: ETC. Dies entspricht /etc unter Unix. Die énderung bewirkt, daû die
Datei help, die nach Eingabe des gleichnamigen Kommandos angezeigt wird,
jetzt nicht mehr auf $HOME, sondern auf $ETC erwartet wird.
ABHILFE: keine, da ETC beim Start der Shell auf denselben Wert wie HOME ge-
setzt wird. Wer allerdings ETC Ñndert, muû dafÅr sorgen, daû auch die Datei
help in das neue Verzeichnis kopiert wird.


			=======
@(#)			18.4.91
			=======

Die Syntax des exec-Kommandos wurde verÑndert: wenn mit dem Flag -x ein
zuvor geladenes Programm gestartet wird, muû jetzt der Dateiname nicht mehr
angegeben werden. DafÅr kînnen solchen Programmen ab jetzt aber auch Parameter
Åbergeben werden.
ABHILFE: öberall, wo `exec -x file.prg 0xabc' steht, `file.prg' streichen.


			=======
@(#)			20.4.91
			=======

		P O R T I E R U N G

Ab heute wird die Shell mit einem neuen Compiler (Laser-C) erstellt. Erste
Versuche ergaben, daû dieser sich in SpezialfÑllen anders verhÑlt als das
vorher benutzte Megamax-C. Wenn irgendwelche Dinge nicht oder nicht mehr
so wie gewohnt funktionieren, so ist das mit groûer Wahrscheinlichkeit auf
solche FÑlle zurÅckzufÅhren. BITTE SOFORT MELDEN!!!! Sie erhalten dann um-
gehend eine korrigierte Version.



			======
@(#)			9.8.91
			======

Die Shellvariablen LOGNAME und VERSION werden von der Shell nicht mehr
gesetzt. Stattdessen enthÑlt jetzt OKAMISHELL die Versionsnummer der
Shell.
Shellscripts, die diese beiden Variablen benutzen, mÅssen umgeschrieben
werden: statt $LOGNAME schreibt man "Okami Shell", statt $VERSION
schreibt man $OKAMISHELL. FÅr beides zusammen kann man auch `ver -o`
benutzen.



			=======
@(#)			31.8.91
			=======

		schon wieder  P O R T I E R U N G

Und zwar diesmal auf Pure-C, den Nachfolger von Turbo-C.
Auch hier bitte alle Eigenartigkeiten sofort melden.



			========
@(#)			27.10.91
			========

Ab heute bearbeitet die Okami-Shell ihre Kommandozeile wie die Original-
Bourne-Shell, d.h. einzelne Parameter stellen die Namen von zu startenden
Shellscripts dar, es kînnen set-Flags eingestellt werden, und ein auszu-
fÅhrendes Kommando muû nach -c stehen. Das bedeutet, daû Programme, die
die Shell auf die bisherige Weise mit Pexec aufrufen, angepaût werden
mÅssen. Programme, die die Shell Åber _shell_p (mit der system-Funktion)
aufrufen, brauchen nicht angepaût zu werden.

Anpassung: Vor das von der Shell auszufÅhrende Kommando -c schreiben.
Wenn also vorher die Shell mit der Kommandozeile "ver ; read" aufge-
rufen wurde, so muû jetzt "-c ver ; read" benutzt werden. 


			======
@(#)			9.5.92
			======

Die Shell verwendet jetzt das &-Zeichen, um Hintergrundprozesse zu starten.
Das bedeutet, daû ein & gequotet werden muû, wenn es ausgegeben werden soll.
Beispiel:
	echo Meier & Co
ergab frÅher die Ausgabe "Meier & Co", jetzt wird "echo Meier" ausgefÅhrt
und dann das Programm Co gesucht (und, falls gefunden, gestartet).
Abhilfe: Åberall, wo ein & ungequotet in einem Shellscript steht, ein ^
davorsetzen, also:
	echo Meier ^& Co
oder Single-Quotes benutzen:
	echo 'Meier & Co'


			=======
@(#)			15.8.92
			=======


Seit heute besitzt die Shell ein Kommando namens find, das dem Unix-
Original mit diesem Namen entspricht. Das vorherige Kommando namens
find wurde deswegen umbenannt in seek. Das neue find ist wesentlich
mÑchtiger als die bisherige Variante, aber leider nicht aufruf-
kompatibel.

Maûnahme: in allen Shellscripts nach "find" suchen und durch "seek"
ersetzen.
