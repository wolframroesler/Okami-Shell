
        ===============================================


@(#)      OKAMI SHELL VERSION 1.4 - BENUTZERANLEITUNG


        ===============================================
                        Stand: 19.9.1992




                BITTE ERST DIE DATEI README LESEN!


----------------------------------------------------------------------------



EINFšHRUNG

Die Okami-Shell (man spricht es "O-Kammi")  ist ein (weiterer)  Versuch,
auf  dem  Atari  ST  so etwas wie Unix-Gefhle aufkommen zu lassen.  Das
Programm   wendet   sich   an   alle,    die   die  M”glichkeiten  eines
Kommandointerpreters  denen  des  Desktops vorziehen.  Die Shell ist vor
allem beim Betrieb mit einer Festplatte ausgesprochen ntzlich. 

Obwohl  es  schon  einige Programme dieser Art gibt,  gibt es gewichtige
Grnde,  die  Okami-Shell  zu  benutzen  und  sich  durch  die  folgende
Anleitung zu arbeiten. 

Die  Okami-Shell ist einer der Unix-orientierten Kommandointerpreter fr
den  ST,   der  die Unix-M”glichkeiten der Ein/Ausgabe-Umleitung und des
Pipelinings  auch fr die internen (in der Shell eingebauten)  Kommandos
erm”glicht.    Die   Ein/Ausgabe-Umleitung  ist  die  M”glichkeit,   die
Standard-Ausgabe eines Programmes,  d.h.  alles, was mit printf, Cconout
etc.  ausgegeben wird und normalerweise auf dem Bildschirm landet, sowie
die  Standard-Eingabe  in  eine  Datei  oder  zu  einem Ger„t (z.B.  zum
Drucker)   umzuleiten.   Die  Umleitung  funktioniert  unter TOS mit dem
GEM-Desktop  a)   nur  bei  TTP-Programmen,  weil man nur bei diesen die
M”glichkeit  hat,   eine  Kommandozeile  einzugeben,   und  b)  nur  bei
Programmen,  deren Compiler die Umleitung untersttzen.  Die Okami-Shell
fhrt  die  Umleitung  selber  durch,  wodurch auch Programme,  die ihre
Kommandozeile    nicht    beachten   (z.B.    solche,    die   mit   dem
Pd-Modula-2-System erstellt wurden), umgeleitet werden k”nnen. 

Die   Okami-Shell   kann  allerdings  noch  etwas  mehr:   sie  ist  ein
universelles Utility,  mit dem man nicht nur Programme starten,  sondern
auch  Programme  schreiben  und debuggen usw.  kann.  Als Bonbon hat sie
einen  eingebauten  UPN-Rechner  mit  ca.   80  Funktionen  sowie  einen
Terminal-Emulator.   Alles  in allem bietet die Okami-Shell mehr interne
Kommandos  und  Funktionen  als  jede  andere  fr den Atari erh„ltliche
Shell. 

Bei  der  Programmierung  einer  Shell  oder  eines Kommandointerpreters
steht  man immer vor der Frage,  ob man fr die in der Shell eingebauten
Kommandos  Unix-,   MS-DOS-  oder  eine  selbstausgedachte  Schreibweise
benutzen soll,  d.h.  ob man die Kommandos ls oder dir,  mv oder rename,
cp  oder  copy  nennen  soll  oder  ob  man  sich  eingene Kommandonamen
ausdenkt.   Die  Okami-Shell  ist  an den Unix-Bezeichnungen orientiert,
genauer gesagt an dem Unix-Derivat AIX,  das z.B. auf dem IBM RT PC 6150
l„uft.  Natrlich mssen bei soetwas Abstriche gemacht werden, der Atari
ist   schlielich   keine   Unix-Maschine,   und  eine  Shell  ist  kein
Betriebssystem. 

Wer sich in Unix einigermaen auskennt,  kann mit der Okami-Shell sofort
loslegen.   Die  folgende Anleitung stellt die Verwendung der Shell dar,
die  Erkl„rung  der  internen  Kommandos mit Syntax befindet sich in der
Datei commands.doc. 

Um  die  vielen  Versionen  der Shell unterscheiden zu k”nnen,  gibt das
Kommando    `ver'    eine    Information    mit    Versionsnummer    und
Kompilierungszeitpunkt aus.  Zur Interpretation der Versionsnummer siehe
tricks.doc. 

----------------------------------------------------------------------------



SUPPORT

Die Okami-Shell ist Public Domain,  d.h.  sie kann von jedermann benutzt
und  weitergegeben werden,  ohne da jemand etwas dafr zu bezahlen hat.
Wer ber E-Mail zu erreichen ist,  sollte mir ber das Maus- oder Usenet
eine  kleine Nachricht,  evtl.  mit Kommentaren,  Anregungen und Kritik,
zukommen lassen. Adresse siehe unten. 

šber den Support ist es jederzeit und fr jeden m”glich: 
1) die neueste Version der Shell zu bekommen, 
2) konfektionierte    Versionen    zu    erhalten,    in    denen    die
Systembeschr„nkungen (Anzahl der Variablen,  Funktionen etc.)  ver„ndert
sind. Wer also eine Version braucht, die bis zu 2000 Variablen verwalten
kann,   kann  eine solche bekommen.  Auerdem k”nnen beliebige Kommandos
ausgeblendet werden,  um die Shell kleiner zu machen.  Wer also z.B. den
UPN-Rechner  und  das  basep-Kommando  nicht  braucht,   kann eine Shell
erhalten,   in  der  diese  Kommandos nicht enthalten sind und die somit
entsprechend krzer ist. 
3) Auerdem   ist  eine  "CLI-Only"-Version  erh„ltlich,   die  nur  die
allerwichtigsten  Kommandos  zur  Bedienung  der  Shell  enth„lt.  Diese
Version ist ungepackt ca.  63 KB gro (die Vollversion ca.  130 KB)  und
kann auf Systemen eingesetzt werden, auf denen die wichtigsten Kommandos
als externe Programme zur Verfgung stehen. 

Es  ist verboten,  die Shell zu verkaufen oder unter einem anderen Namen
zu vertreiben.  Wer irgendwelche Teile des Programms oder der Quellen in
eigenen  Programmen benutzen will,  darf dies tun,  solange mein Name im
Programm und in der Dokumentation erw„hnt wird. 
Die Datei `copying' enth„lt genaue Hinweise zum Kopieren und Weitergeben
der Shell. 

Das   Programm   wird   voll   untersttzt,   d.h.   es  wird  dynamisch
weiterentwickelt,  und jeder Anwender kann bei mir jederzeit die neueste
Version  bestellen.   Ebenso  stehe  ich  bei Problemen und Wnschen zur
Verfgung.   Spenden  sind natrlich auch willkommen,  aber ausdrcklich
nicht  Vorraussetzung  fr  den Erwerb von neuen Versionen,  Anleitungen
oder  sonstigen  Hilfen (dies ist allen Pd-Programmierern zur Nachahmung
empfohlen). 

Meine Adresse: 
        Wolfram R”sler
        Augustastr. 44-46
        W-5100 Aachen
        Tel. +49 (0)241 534596
        Mausnetz: Wolfram R”sler @ AC2
        Usenet:   wr@bara.oche.de

Bitte    bei    allen    Zuschriften    die   Versionsnummer   und   das
Kompilierungsdatum  der  Shell  angeben  (werden durch Eingabe von "ver"
ausgegeben).   Bei  Fehlermeldungen  bitte  die  Ausgabe  von  "ver  -a"
mitschicken. 

Wer  irgendwelche  Anregungen fr weitere Versionen der Shell hat,  kann
sich damit jederzeit an mich wenden. 

----------------------------------------------------------------------------



PROGRAMMFEHLER


        "Selbst der  umsichtigste Programmierer kommt manchmal in Situationen,
        wo das Programm nicht richtig funktioniert."
                         Texas Instuments, "Individuelles Programmieren"
                         Handbuch zu TI 58/58C/59, 1977

Der  Software-Support deckt die Beseitigung von Fehlern in der Shell ab.
Wer  einen  Fehler  findet,  sollte also nicht die Okami-Diskette in die
Ecke  schmeien  und  sich einer anderen Shell zuwenden (die hat n„mlich
auch   Fehler),    sondern  mir  einen  Hinweis  mit  m”glichst  genauer
Fehlerbeschreibung   schicken.    Wenn   man  eine  Diskette  und  einen
frankierten  Rckumschlag  beilegt,  bekommt man die korrigierte Version
der  Shell  sobald wie m”glich zurck.  Wenn die Shell in Verbindung mit
einem anderen Programm Probleme macht, sollte man dieses Programm gleich
mitschicken.   Bitte  bei allen Fehlermeldungen die Ausgabe von "ver -a"
mitschicken. 
Natrlich  kann  ich  keine Verantwortung fr irgendwelche Sch„den,  die
durch  die  Shell,   ihre Anwendung oder die Unf„higkeit ihrer Anwendung
verursacht werden, bernehmen. Wer also unbedingt 
                       df -mn | xargs rm -r {}/* 
ausprobieren mu, hat das Ergebnis selber auszubaden. 

----------------------------------------------------------------------------



LIEFERUMFANG


Zur Okami-Shell geh”ren die folgenden Dateien: 
        KERN:
        sh.ttp          Das Haupt-Shellprogramm.
        msh.prg         Die Microshell zum Starten als GEM-Programm.
        msh.inf         Konfigurationsdatei zur Microshell.
        profile         Konfigurationsdatei beim Start der Shell.
        help            Textdatei mit Syntaxerkl„rungen.
        EXTERNE KOMMANDOS:
        calc.sh         Benutzerschnittstelle zum eingebauten UPN-Rechner.
        format.ttp      Programm zum Formatieren von Disketten.
        gem.prg         Programm zur Benutzung von Accessories.
        gem.rsc         Resourcedatei dazu.
        showpic.sh      Demo-Shellscript zur Anzeige von Bilddateien.
        QUELLEN:
        msh.c           msh.prg
        gem.c           gem.prg
        format.c        format.ttp
        DOKUMENTATION:
        readme          Grundeinfhrung fr den Anwender.
        doc\*.*        Anleitungen.
        SONSTIGES:
        dial.inf        Eine Beispieldatei fr das dial-Kommando.
        okami.pic       Das Titelbild.
        okicon.rsc      Eine Resourcedatei, die drei Icons mit dem
                        Okami-Logo enth„lt.
        _index          Indexdatei fr `ls -i'.

----------------------------------------------------------------------------



SYSTEMANFORDERUNGEN


        "Wie der Name unschwer erkennen l„t, besitzt der Atari 520 ST
        einen enormen Hauptspeicher, n„mlich ganze 512 KByte. Der eine
        oder andere kann sich vielleicht schwer vorstellen, wozu dieser
        Riesenspeicher ben”tigt wird."
                                Data Becker, "Das groe GEM-Buch" (1985)

Die Okami-Shell stellt folgende Anforderungen an das System: 

Rechner

    L„uft auf jedem ST-kompatiblen Rechner. šber den Einsatz auf anderen
    Rechnern mit ST-Emulator liegen noch keine Testergebnisse vor. 


RAM

    Die Shell ben”tigt ca.  200 KB an Laufzeitspeicher => lauff„hig auch
    auf 512KB-Maschinen. Empfohlen werden allerdings 1 MB oder mehr. 


Massespeicher

    Fr  die  zum  Lauf  notwendigen  Dateien werden minimal ca.  120 KB
    ben”tigt.  Mit allen Hilfsdateien (Microshell,  Profile,...)  werden
    ca.   200  KB  ben”tigt.   Dazu  kommen noch die ber 300 KB fr die
    Dokumentation. 
    Die  Shell  kann  jedem  Massespeicher  betrieben  werden.  Fr  die
    Verwendung  des  Pipelinings ist es jedoch notwendig,  da auf einen
    Massespeicher  (nicht  notwendigerweise  den,   von  dem  die  Shell
    gestartet  wurde)   geschrieben  werden kann.  Fr diesen Zweck kann
    auch eine eigene kleine Ramdisk verwendet werden (16-32K). 


Bildschirm

   L„uft  in  jeder  Aufl”sung.   Der Betrieb in niedriger Aufl”sung ist
   m”glich, aber einige interne Kommandos gehen davon aus, das pro Zeile
   80  Zeichen  zur  Verfgung  stehen (z.B.  df und hd).  Die Benutzung
   dieser  Kommandos  kann  dann  zu  St”rungen in der Bildschirmausgabe
   fhren. In keinem Fall kommt es jedoch zu einem Programmabsturz. 
   Sollte  mit  jeder  Farb-  und  Schwarzwei-Emulation  funktionieren.
   Sollte  auch  mit  allen  Grobildschirm arbeiten (ungetestet mangels
   Grobildschirm).   Die Shell untersttzt OverScan (siehe commands.doc
   zu dem internen Kommando "overscan"). 


Hardware

   Die Shell untersttzt Maus, Drucker und die RS232-Schnittstelle sowie
   ein  Modem.   Es  werden  jedoch  keine  Ger„te  auer Bildschirm und
   Tastatur  unbedingt  ben”tigt  (auch nicht die Maus).  (Genaugenommen
   werden nicht einmal Bildschirm und Tastatur unbedingt ben”tigt.) 


Betriebssystem

   Die  Shell  wurde unter TOS 1.02 und 1.04 auf einem Atari 1040 ST und
   Mega ST4 entwickelt und ist "sauber"  programmiert,  d.h.  es erfolgt
   kein  Zugriff  auf  undokumentierte oder ver„nderliche Systemadressen
   o.„.   Die  Shell sollte daher mit jedem frheren und zuknftigen TOS
   zusammenarbeiten. Sie arbeitet mit und untersttzt MiNT. 


Software

   Jedes TOS-  und TTP-Programm kann von der Shell als externes Kommando
   aufgerufen werden.  GEM-Programme k”nnen aufgerufen werden,  wenn die
   Shell selber als GEM-Programm gestartet wird,  was z.B. der Fall ist,
   wenn msh.prg zum Start der Shell benutzt wird. 
   Zum  Ver„ndern  der Konfigurationsdateien profile und msh.inf ist ein
   Ascii-Editor erforderlich. 

----------------------------------------------------------------------------



INSTALLATION

Die  Okami-Shell  kann  direkt  von der Diskette gestartet werden.  Siehe
hierzu den folgenden Abschnitt. 
Ihre  volle  Effizienz  entwickelt die Shell allerdings erst beim Einsatz
von der Ramdisk oder Festplatte. 


INSTALLATION AUF RAMDISK

Ich  empfehle  die  selbstkomprimierende  Maxidisk,   da sie die optimale
Speicher  ausnutzung garantiert.  Fr die Shell sollten mindestens 200 KB
Maxidisk oder ca. 300 KB einer anderen Ramdisk zur Verfgung stehen. 

Fr  den  vollen Betrieb der Shell sollten folgende Dateien (am besten in
einen eigenen Ordner) auf die Ramdisk kopiert werden: 

        sh.ttp
        profile
        msh.prg
        msh.inf
        help
        okami.pic
        dial.inf
        _index
  in einem Unterordner namens doc:
        commands.doc            <------ aus dem Anleitungsordner
  in einem Unterordner namens bin:
        *.sh
        format.ttp
        gem.prg
        gem.rsc
        ship.exe                 <------ fr Festplattenbenutzer: das
                                        ship.prg der Harddisk-Utility-Disk



Die  Datei  help  wird fr das Shell-Kommando "help"  benutzt;  wer diese
Datei  ausdruckt und neben den Rechner legt,  kann sich den Platz auf der
Ramdisk  ebenfalls sparen.  Dasselbe gilt fr commands.doc,  das auerdem
ziemlich  viel  Platz  beansprucht.   (Auf  der  Platte -  auf dem Papier
allerdings   auch,   auerdem  wird  commands.doc  fr  die  Online-Hilfe
ben”tigt.) 
Die Dateien msh.prg und msh.inf geh”ren zusammen und werden zum Start der
Shell  als  GEM-Programm  benutzt.  Wer von der Shell keine GEM-Programme
starten will, braucht diese Dateien nicht. 
Auf  die  externen  Kommandos  wie gem und format kann man natrlich auch
verzichten, nur mu man dann u.U. etwas h„ufiger ins Desktop zurck. 
Wer  kein  Modem  hat,   kann  mit  dem dial-Kommando nichts anfangen und
braucht folglich auch kein dial.inf. 
Wer  nicht  bei  jedem  Systemstart das Titelbild sehen m”chte,  kann die
Datei okami.pic umbenennen oder l”schen. 
Auch auf profile kann man verzichten,  allerdings wird die Shell dann mit
den eingebauten Voreinstellungen initialisiert. 
=> Die einzige Datei, die man wirklich braucht, ist sh.ttp. 


INSTALLATION AUF FESTPLATTE

Bei  der  Installation der Shell auf Festplatte kommt echtes Unix-Feeling
auf,   vor  allem  wenn  man  die  Shell nach dem Systemstart automatisch
starten l„t (ich empfehle zum Autostart: 
        TOS 1.0: den Autostarter aus dem Data Becker-Buch "Die besten
                 Tips&Tricks fr Atari ST", S. 24ff.
        TOS 1.2: den Autostarter "startgem.prg", der zu Superboot 6.0
                 geh”rt, siehe PD-Journal 9/90, S. 43ff.
        >= TOS 1.4: msh.prg im Desktop als Autostart-Applikation anmelden)

Mit einigen Tricks,  die im folgenden erkl„rt werden,  kann man sich z.B.
bei  jedem  Start  der  Shell  Datum und Uhrzeit des letzten Systemstarts
ausgeben  lassen oder das aktuelle Arbeitsverzeichnis so einstellen,  wie
man  die  Shell zuletzt verlassen hat.  Auerdem kann man alle Programme,
die man auf der Festplatte hat,  per Name starten lassen, egal in welchem
Verzeichnis   man  sich  gerade  befindet,   und  es  werden  sogar  alle
RSC-Dateien gefunden. 
Man tippt also z.B. ein: 
                             edit datei.txt 
und  es  erscheint  der  Editor  mit  der  Datei  datei.txt,   egal wo im
Dateisystem der Editor sich befindet. 

Fr  die Shell sollte ein eigener Ordner eingerichtet werden,  in den die
oben unter INSTALLATION AUF RAMDISK aufgefhrten Dateien kopiert werden. 

Auerdem  ist  es sinnvoll,  Pipe-Operationen ber eine Ramdisk laufen zu
lassen. Siehe dazu weiter unten. 

Wenn  man  sich  die  Anleitungen  der  Shell auf die Festplatte kopiert,
braucht  man die Datei commands.doc nicht noch einmal in den Shell-Ordner
zu  kopieren.   Dann mu allerdings der Dateiname von commands.doc in der
Shell-Variablen HELPFILE gespeichert werden. Siehe dazu weiter unten. 


INSTALLATION IM AUTO-ORDNER

Es  ist  sehr  sinnvoll,  ein  kleines  Programm  zu  schreiben,  das  im
Auto-Ordner  gestartet wird und,  wenn eine bestimmte Taste gedrckt ist,
die Shell per Pexec ausfhrt. Wenn dies das erste Programm im Auto-Ordner
ist, hat man immer die Gelegenheit, vor dem Start irgendwelcher Programme
in die Shell zu gelangen und so z.B.  defekte Programme, die das korrekte
Hochfahren des Systems verhindern, zu deaktivieren. Die Shell fhrt keine
AES-Aufrufe  aus,  die beim Start aus dem Auto-Ordner zu Problemen fhren
wrden, da zu dieser Zeit das AES noch nicht initialisiert ist. Die Shell
fhrt AES-Aufrufe erst dann aus,  wenn der Anwender sie durch Eingabe des
Kommandos  `gon'   explizit  dazu  auffordert.   Aus diesem Grund ist ein
Betreiben der Shell aus dem Auto-Ordner problemlos m”glich. 


INSTALLATION IM COOKIE-JAR

Der  Cookie-Jar  ist  eine  M”glichkeit  des  Betriebssystems,   mit  der
installierte  Programme  dem System ihre Anwesenheit nebst Versionsnummer
mitteilen k”nnen.  Der Cookie-Jar wird erst ab TOS 1.6 vom Betriebssystem
selber  benutzt,   kann  aber  bei  allen frheren TOS-Versionen auch von
Programmen  installiert  werden.   Die  Okami-Shell  tr„gt sich unter der
Kennung  "OkSh"   in  den  Cookie-Jar  ein.  Vorher installiert sie einen
solchen, falls noch keiner vorhanden ist. Die Versionsnummer ist auf zwei
Bytes aufgeteilt,  bei Version 1.5 steht eine 5 im niedrigsten und eine 1
im n„chsth”heren Byte. 
Mit  dem  internen  Kommando  `cookie'  kann  der  Cookie-Jar  ausgelesen
werden. Siehe hierzu commands.doc. 
Wenn  die  Shell  beendet  wird,  wird  der  vorherige  Wert  wieder  als
Cookiejar-Adresse  eingetragen.  Beim Beenden der Shell mit shutdown wird
als Cookiejar-Adresse 0 eingetragen. 

----------------------------------------------------------------------------



START DER SHELL



a) Direkt
Die Shell wertet ihre Kommandozeile nach der folgenden Syntax aus: 

                [-] [Flags] [[-- | -c] Cmd [Parameter]] 

Es bedeuten: 

-

   Es  wird  die  Datei  profile im aktuellen Directory geladen.  Wenn -
   nicht angegeben ist,  wird keine Profile-Datei geladen. (In Unix wird
   das -  als erstes Zeichen von argv[0] bergeben. Das l„t sich in TOS
   nicht bewerkstelligen, also mu das - in der Kommandozeile stehen.) 


Flags

   Beliebige  der  Flags,   die auch fr das Kommando set benutzt werden
   k”nnen  und  das  Verhalten der Shell global beeinflussen.  Die Flags
   k”nnen  also  schon  in  der  Kommandozeile  eingestellt werden,  was
   ntzlich ist,  wenn kein Profile benutzt wird. Die Flags k”nnen mit +
   oder - beginnen. Siehe commands.doc fr weitere Details. 


--

   Stellt  das  Ende  der  Flags dar und signalisiert,  da die weiteren
   Parameter zu `Cmd'  geh”ren.  --  wird nur ben”tigt,  wenn `Cmd'  mit
   einem Minus- oder Pluszeichen beginnt. 


-c

   Signalisiert,   da es sich bei `Cmd'  um ein auszufhrendes Kommando
   (intern oder extern)  handelt. Wenn -c nicht benutzt wird, wird `Cmd'
   als der Dateiname eines auszufhrenden Shellscripts betrachtet. 


Cmd

   Ein  auszufhrendes  Kommando  oder  Shellscript.  Wenn Cmd angegeben
   ist,   wird  die Shell nach seiner Ausfhrung beendet.  Wenn kein Cmd
   angegeben ist, wird die Shell interaktiv. 


Para

   Optionale Parameter fr Cmd. 


Anmerkung:  šber den Software-Support kann eine Shell bezogen werden, die
sich  im  Hinblick  auf  das  bergebene  Minuszeichen  genau andersherum
verh„lt, d.h. sie initialisiert sich mit dem Profile immer, auer es wird
ein Minuszeichen bergeben. 

Beispiele: 

sh

   Die Shell wird interaktiv gestartet. Es wird kein Profile geladen. 


sh -

   Die  Shell wird interaktiv gestartet.  Die Datei profile im aktuellen
   Directory  oder  (falls  gesetzt)   die  in der Environment-Variablen
   OKSH_PROFILE  angegebene  Datei  wird  geladen.  Dies ist der normale
   Start der Shell. 


sh - -i

   Die Shell wird interaktiv gestartet,  die Datei profile wird geladen,
   und es wird der Insert-Modus des Zeileneditors abgeschaltet (-i). 


sh myscript

   Die  Datei myscript wird als Shellscript ausgefhrt,  danach wird die
   Shell beendet. 


sh -x myscript

   Die  Datei myscript wird als Shellscript ausgefhrt,  danach wird die
   Shell  beendet.   Vorher wird das Flag x gel”scht,  wodurch die Shell
   beim  Start  von  Bin„rprogrammen  das aktuelle Verzeichnis nicht auf
   das Verzeichnis einstellt, in dem die Programmdatei enthalten ist. 


sh -L <myscript

   Das  Flag  L  wird  gel”scht,   wodurch  die  Shell Kommandos von der
   Standardeingabe   (statt  mit  dem  Zeileneditor  von  der  Tastatur)
   einliest.  Dadurch wird die Datei myscript ausgefhrt.  Diese Art des
   Startens  eines  Shellscripts  unterscheidet sich nur geringfgig von
   dem  direkten Angeben des Shellscripts und kann z.B.  benutzt werden,
   um Kommandos von einer Pipeline oder einer Schnittstelle auszufhren.



sh -c ver

   Die Shell fhrt das Kommando `ver' aus und terminiert. 


b) Indirekt
Die  Shell  kann  indirekt von jedem Programm aus mit der GEMDOS-Funktion
Pexec  gestartet  werden.   Dies  geschieht  z.B.  beim  Aufruf  von  der
Microshell.   Da  die  Shell  den  Environment-String  benutzt,   sollten
Programme,   die  das  nicht  tun,   als letzten Parameter von Pexec eine
(long)0 bergeben (und nicht einen Leerstring).  Wenn der Shell dabei ein
Parameterstring  bergeben  wird,   so  wird  dieser wie oben beschrieben
ausgefhrt.  Der Parameterstring kann der Shell auch nach dem xArg-  oder
ARGV-Verfahren bergeben werden. 

Wenn  die Shell als Login-Shell gestartet werden soll und es m”glich sein
soll,  GEM-Programme von der Shell aus zu starten,  mu die Shell mit der
Microshell   (msh.prg)    gestartet   werden.    Dazu   mssen   folgende
Voraussetzungen zutreffen: 
1) Im selben Directory wie sh.ttp stehen die Dateien msh.prg und msh.inf.

2) Die Datei msh.inf enth„lt mindestens die folgende Zeile: 

                                sh.ttp - 

Dann  wird  die  Shell  nach  Doppelklick  auf  msh.prg  automatisch  als
Login-Shell  gestartet.   Es  k”nnen alle GEM-Programme von der Shell aus
ausgefhrt werden. Siehe hierzu auch msh.doc. 

Wenn  die  Shell  auf diese Weise vom Desktop aus gestartet wird,  sollte
das Profile die Zeile 

                             trap cursor -v 
enthalten.  Dann wird nach dem Ende der Shell automatisch der Cursor abge
schaltet  (auf  dem  Desktop  st”rt  er  ziemlich).   Siehe  hierzu  auch
commands.doc. 

c) šber den Shellpointer (_shell_p)
Der  Shellpointer befindet sich in Adresse 0x4F6 und enth„lt einen Zeiger
auf eine Funktion,  die ein ihr bergebenes Kommando ausfhrt.  Auf diese
Weise  ist  es m”glich,  aus einem von der Shell gestarteten Programm aus
Shellkommandos  auszufhren,   ohne  da die Shell nochmal geladen werden
mu. Ein Beispiel fr die Verwendung ist das mitgelieferte gem.prg. 

Die  Funktion,   deren  Adresse  in  0x4F6 hinterlegt wird,  hat folgende
Syntax: 
        int Fct(char *cmd)

`cmd'   ist  ein  String  mit dem auszufhrenden Kommando.  Dies kann ein
beliebiges  Shell-Kommando  sein.  Mehrere  Kommandos  k”nnen  durch  `;'
verkettet  werden.  Wenn ein leerer String oder ein NULL-Zeiger bergeben
wird,   arbeitet  die  Shell  im  Dialogmodus,  ansonsten  wird  nur  cmd
ausgefhrt. Zurckgegeben wird der Rckgabewert des Kommandos. 

Achtung:   Bei  dieser  Art  des Aufrufes wird die bereits laufende Shell
ausgefhrt. Das bedeutet, da alle Shellvariablen und Shellfunktionen der
laufenden  Shell  benutzt  und ver„ndert werden k”nnen.  Die vollst„ndige
Reentranz  der  Shell  kann jedoch nicht garantiert werden.  Insbesondere
sollten  mit  einer  auf diese Weise gestarteten interaktiven Shell keine
externen Programme aufge rufen werden.  (was allerdings teilweise m”glich
ist und offenbar von dem betreffenden Programm abh„ngt.) 

---------------------------------------------------------------------------



KONFIGURATION

Wenn  der  Shell  als einziger Parameter ein Minuszeichen bergeben wird,
sucht  sie  nach  dem  Start  im aktuellen Verzeichnis eine Datei mit dem
Namen  profile.   Wenn die Environment-Variable OKSH_PROFILE gesetzt ist,
wird  stattdessen  die in dieser Variable angegebene Datei benutzt.  Wenn
diese  Datei  vorhanden  ist,   wird  sie wie ein Shellscript (siehe dazu
weiter unten)  ausgefhrt. Das Profile kann eine Einschaltmeldung auf dem
Bildschirm ausgeben und Shellvariablen wie z.B.  das Prompt (PS1) setzen.
Auerdem  k”nnen  die  Shell-Flags eingestellt werden (siehe dazu das in-
terne  Kommando  `set'  in commands.doc).  Das Profile kann alle Aktionen
ausfhren, die ein normales Shellscript auch ausfhren kann. Siehe hierzu
auch tricks.doc. 

----------------------------------------------------------------------------



KOMMANDOEINGABE



a) Von der Tastatur
Wenn  die  Shell  im  Dialogmodus  gestartet ist,  k”nnen nach dem Prompt
(i.d.R.    ein   Dollarzeichen)   Kommandos   eingegeben   werden.   (Das
mitgelieferte  Profile  stellt das Prompt um,  so da im Prompt immer das
augenblickliche aktuelle Directory zu sehen ist.) 

Mit  dem  internen  Kommando keydef kann jede beliebige Taste umdefiniert
werden.   Das  bedeutet,  da alle der unten angefhrten Tastenfunktionen
ungltig  werden  k”nnen,  wenn die jeweiligen Tasten umdefiniert werden.
Die einzigen Funktionen,  die nicht umdefiniert werden k”nnen, sind ENTER
und  Ctrl  Shift  Undo.  Fr weitere Informationen siehe commands.doc zum
Thema keydef. 

Bei der Eingabe werden folgende Sondertasten benutzt: 

Backspace

   bewegt den Cursor nach links und l”scht das dort stehende Zeichen. 


Pfeil auf

   Es  wird das zuletzt eingegebene Kommando angezeigt.  Dieses kann mit
   ENTER   bernommen   oder   mit  Backspace  editiert  werden.   Durch
   wiederholten   Druck  auf  Pfeil  auf  wird  das  vorletzte  Kommando
   angezeigt usw.  Es werden maximal 100 Kommandos gespeichert (wer mehr
   braucht,    benutze   den  Software-Support,   um  eine  entsprechend
   angepate  Version  der  Shell  zu  erhalten.)  Diese Eigenschaft der
   Eingabe nennt man "History". 


Shift Pfeil auf

   Wie  Pfeil  auf,   aber  es  wird  die  letzte  Zeile aus der History
   angezeigt,   die  mit der bisherigen Eingabe bereinstimmt.  Gibt man
   also  ein  "ls "   und  drckt Shift Pfeil auf,  dann wird das letzte
   ls-Kommando zurckgeholt.  Der Zeiger in der History-Liste steht dann
   hinter  dieser  Zeile,  ein weiterer Druck auf Shift Pfeil Auf bringt
   also das vorletzte ls-Kommando zurck usw. 


Ctrl Pfeil auf

   Wie  Pfeil  auf  gefolgt von einem Druck auf ENTER,  es wird also das
   zuletzt  eingegebene  Kommando  nicht  nur  angezeigt,  sondern  auch
   ausgefhrt. Geht auch zusammen mit Shift. 


Pfeil ab

   Zeigt  das  n„chste  Kommando in der History-Liste an.  Mit Pfeil auf
   und  Pfeil ab kann man also in den in der History-Liste gespeicherten
   Kommandos bl„ttern. 


Shift Pfeil ab

   Analog zu Shift Pfeil auf. 


Ctrl Pfeil ab

   Wie Pfeil ab gefolgt von einem Druck auf ENTER,  analog zu Ctrl Pfeil
   auf. 


Shift Esc

   Dateinamen-Vervollst„ndigung fr alle Dateien, die auf ein Suchmuster
   passen. Siehe unten. 


Esc

   Dateinamen-Vervollst„ndigung fr eine Datei. Siehe unten. 


Pfeil links/rechts

   bewegen  den  Cursor:   mit Shift zum Zeilenanfang/ende,  mit Control
   jeweils  ein  Wort nach links/rechts,  sonst jeweils ein Zeichen nach
   links/rechts. 


Delete

   mit  Control:  l”scht  die  Zeile  von  der  Cursorposition  bis  zum
   Zeilenende. Sonst: l”scht das Zeichen unter dem Cursor. 


Shift Space

   Speichert die aktuelle Position fr Pfeil rechts. Siehe unten. 


Clr-Home

   Die Eingabezeile wird gel”scht. 


Help

   Es  wird eine Erkl„rung des eingegebenen Kommandos ausgegeben.  Siehe
   unten. 


Ctrl Shift Undo

   Fr  diese  Eingabezeile  wird die Tasten-Redefinition ausgeschaltet.
   Die  Eingabe  verh„lt  sich also so,  als ob seit dem Start der Shell
   keine  keydef-Kommandos  ausgefhrt  worden w„ren.  Die Funktion wird
   durch ein Klingelzeichen best„tigt. 


Control V

   Das   n„chste   eingegebene  Zeichen  wird  nicht  als  Steuerzeichen
   interpretiert. Auf diese Weise kann man z.B. VT52-Sequenzen eingeben:

                            echo <ESC>E 

   geht  nicht,   da das ESC interpretiert wird (und Filename-Completion
   einleitet), man mu es so eingeben: 

                        echo <Ctrl-V><ESC>E 


Control F

   Es  erscheint eine Fileselect-Box,  der ausgew„hlte Dateiname wird in
   die  Eingabe  bernommen.   Das  geht nur,  wenn gon aktiv ist (siehe
   commands.doc zum Stichwort gon). 


Control P

   Es  wird  eine  Hardcopy ausgefhrt.  Dies geschieht durch Aufruf der
   Shellfunktion  "screensave".   Die Voreinstellung dieser Funktion ist
   ein  einfacher Aufruf des internen Kommandos "hardcopy",  wodurch der
   Bildschirminhalt  auf  dem  Drucker  ausgegeben  wird.   In der Datei
   `tricks.doc'   ist eine screensave-Funktion angegeben,  durch die die
   Hardcopy in eine Datei geschrieben wird. 


Control A

   Der  Bildschirm  wird  dunkelgeschaltet.  Nach  Druck  auf  eine  der
   Shifttasten,   Control  oder  Alternate kann man weiterarbeiten.  (Um
   diese  Funktion  zu  benutzen,   sollte  gon aktiv sein,  da sie dann
   VDI-Funktionen benutzen kann;  wenn gon nicht aktiv ist, schreibt sie
   direkt in den Bildschirmspeicher,  was bei Grobildschirm usw.  nicht
   funktioniert.) 


Alternate Space

   Es  werden  Uhrzeit  und  Datum  angezeigt,   bis die Alternate-Taste
   losgelassen wird. 


Control D

   Die Shell wird beendet. 


Es  k”nnen  beliebige  Ascii-Codes in der Schreibweise `^ooo'  eingegeben
werden, wobei ooo eine dreistellige Oktalzahl ist. Um z.B. Klingelzeichen
in eine Eingabe einzubauen: 
                 echo "Jetzt kommt eine Klingel: ^007" 
Auf  diese  Weise  k”nnen alle VT52-Sequenzen benutzt werden.  Siehe auch
`echo' in commands.doc. 



Dateinamen-Vervollst„ndigung (Filename-Completion):

Die  Shell  bietet  die  M”glichkeit,   nur  einen Teil eines Dateinamens
einzugeben  und  diesen  dann  zu  dem  vollen  Dateinamen expandieren zu
lassen. Dazu gibt es zwei M”glichkeiten: 

1) Nach  Druck  auf  Taste Shift-Escape wird das zuletzt eingegebene Wort
zu  allen  Dateinamen  expandiert,   die  nach den Regeln der erweiterten
Wildcards auf dieses Wort passen. Beispiel: 
 $ cat *.c<SHIFT ESC>
erzeugt 
 $ cat sh.c cmds.c utl.c ...

2)  Nach Druck auf die Taste ESC kann der Anwender aus den auf das letzte
Wort  passenden  Dateien eine ausw„hlen.  Wenn nur eine Datei pat,  wird
diese  direkt bernommen,  ansonsten kann eine Datei mit folgenden Tasten
ausgew„hlt werden: 

Pfeil links/rechts

   die jeweils n„chste/vorige Datei. 


Pfeil auf/ab

   zum Anfang/Ende der Liste. 


Leertaste

   Dateil„nge  und  Anzahl  der  passenden  Dateien  wer den ausgegeben.
   Hierbei bedeutet `4/10' die vierte Datei von insgesamt zehn. 


Return

   der gerade angezeigte Dateiname wird bernommen. 


ESC

   die   Auswahl   wird   abgebrochen,   die  bisherige  Eingabe  bleibt
   unver„ndert. 


Clr-Home

   die  Auswahl  wird  abgebrochen,  das Suchmuster wird aus der Eingabe
   entfernt. 


Help

   eine Tastenbersicht wird angezeigt. 


Sowohl  fr  Pfeil  links  als  auch  fr ESC gilt,  da die Funktion des
eingegebenen  Wortes  mit  dem  Shell-Flag f ver„ndert werden kann.  Wenn
dieses  Flag  gesetzt ist (set +f),  dann stellt das eingegebene Wort ein
Pr„fix dar,  z.B.  steht `abc'  dann fr alle Dateien, deren Name mit abc
anf„ngt.  Wenn  das  Flag  f  nicht  gesetzt  ist  (set  -f),  steht  das
eingegebene Wort nur fr die Dateien, die (nach den Regeln fr erweiterte
Wildcards)   auf  dieses Wort passen,  `abc'  steht dann also nur fr die
Datei abc. 

Zur Verwendung der Help-Taste: 

Mit  der Help-Taste kann jederzeit,  und zwar ohne die Eingabe zu st”ren,
zu   einem   Kommando   die   entsprechende   Anleitung   aus  der  Datei
`commands.doc'  oder einer anderen Hilfsdatei angezeigt werden.  Will man
z.B.  eine Diskette formatieren,  so tippt man das Kommando "format"  ein
und  berlegt dann,  wie die Parameter noch waren -  dann hilft ein Druck
auf Help, und es erscheint die Anleitung zu format. 
Anschlieend kann die Eingabe fortgesetzt werden.  Das funktioniert auch,
wenn bereits Parameter nach format eingegeben worden sind. 
Wenn  man  die Help-Taste bei leerer Kommandozeile drckt,  wird man nach
dem zu erkl„renden Kommando gefragt. 
Bei  der  Angabe  des  zu  erkl„renden  Kommandos  gelten  die Regeln fr
erweiterte Wildcards,  d.h. mit "r*" wird das erste Kommando erkl„rt, das
mit r beginnt usw. 

Beispiel: 

$ format A: <HELP>                                       Eingabe


format - Formatieren von Disketten                      Ausgabe
..... (usw.)


$ format A: *                                            weiter gehts

(In  diesem  Beispiel  steht  <HELP> fr das Drcken der Help-Taste und *
fr die Cursor-Position am Ende. $ ist das Shell-Prompt.) 

Der  Pfadname  der Datei commands.doc mu in der Shell-Variablen HELPFILE
gespeichert sein. Die Voreinstellung ist $HOME\doc\commands.doc. Wenn die
Variable HELPFILE nicht gesetzt ist, wird die Datei help.txt im aktuellen
Directory benutzt. 

Wenn  das  Stichwort  in  der  in  HELPFILE  angegebenen Hilfsdatei nicht
gefunden wird, sucht die Shell nach einer Datei folgenden Namens: 

                             pfad\name.ext 

`pfad'   ist  einer der in der Shell-Variablen MANPATH angegebenen Pfade,
und  `ext'   ist  einer  der  in  der  Shell-Variablen MANEXT angegebenen
Extender.   `name'   ist das eingegebene Stichwort.  Das Suchen der Datei
erfolgt  analog zum Suchen einer Programmdatei mit den Variablen PATH und
SEXT/XEXT. 

Beispiel:  MANPATH=$HOME/doc, MANEXT=.doc, Eingabe: lharc. Dann sucht die
Shell nach einer Datei namens $HOME/doc/lharc.doc.  Die Datei wird, falls
gefunden, mit den eingebauten Kommando pg angezeigt. 

Um  m”glichst  schnellen  Zugriff  auf  die  Hilfsdatei  zu  erm”glichen,
erstellt die Shell nach dem Laden einen Index,  in dem die einzelnen,  in
der Datei enthaltenen Kommandos verzeichnet sind.  Dieser Index wird nach
der  Erstellung  in  eine  Datei  abgespeichert,   die denselben Pfad und
Dateinamen  wie  die  Hilfsdatei,   aber  den  Extender  .idx  hat  (z.B.
commands.idx).   Beim  n„chsten  Laden  der Hilfsdatei wird der Index aus
dieser   Datei  geladen,   was  besonders  bei  Festplatten  eine  enorme
Beschleunigung   gegenber   dem   Neuerstellen  des  Index  im  Speicher
darstellt. 
Wenn  die  Hilfsdatei  neuer  ist als die Indexdatei,  wird ebenfalls ein
neuer  Index erstellt und abgespeichert.  Dadurch wird erreicht,  da die
Indexdatei  immer  zu  der Hilfsdatei pat,  auch wenn letztere ver„ndert
wird.  Wenn man eine neue Indexdatei erstellen will,  gengt es, die alte
Indexdatei zu l”schen. 
Die  Verwendung  einer  Indexdatei kann mit dem Shell-Flag -H unterbunden
werden.  Dies ist wichtig fr Diskettenbenutzer,  bei denen das Laden der
Indexdatei  l„nger  dauert  als  die Neuerstellung des Index im Speicher.
Siehe hierzu commands.doc zum Thema `set'. 

Anstelle  von  commands.doc  kann  auch  jede andere Datei als Hilfsdatei
benutzt  werden.   Damit ein Kommando in der Datei erkannt wird,  mu die
Datei folgende Regeln erfllen: 

1) Vor  dem  Text,   der  das  Kommando erkl„rt bzw.  der zu dem Kommando
ausgegeben werden soll,  mu eine Zeile stehen, die mit fnf Minuszeichen
beginnt. 
2) Direkt  nach dieser Zeile mu eine Zeile stehen,  die mit dem Kommando
beginnt.   Das Kommando geht vom Anfang der Zeile bis (exkl.)  zum ersten
Nicht-Buchstaben (Buchstaben sind a-z und A-Z, keine Umlaute, kein ) und
darf  maximal  10 Zeichen lang sein.  Danach k”nnen weitere Informationen
stehen, die nicht beachtet werden. 
3) Der auszugebene Text beginnt mit der unter 2)  beschriebenen Zeile und
geht bis zur n„chsten Zeile, die mit fnf Minuszeichen beginnt (exkl.). 

Beispiel: 
-----                                                           1)
ls - Anzeigen von Directories                                   2)
                                                                3)
(Weitere Angaben)                                               4)
                                                                5)
-----                                                           6)

Bei der Eingabe von "ls <HELP>" werden die Zeilen 2) bis 5) ausgegeben. 

Natrlich  kann  man auch eine Kopie von commands.doc anfertigen und dort
einige    weitere   beliebige   Informationen   eintragen,    die   unter
entsprechenden Stichworten abgefragt werden k”nnen. 

Die   Ausgabe   erfolgt   wie   mit  dem  Kommando  "pg".   Siehe  hierzu
commands.doc. 



TECHNISCHER HINWEIS

Wenn  die  Hilfsdatei im Speicher steht und von der Shell aus ein anderes
Programm   gestartet   wird,   bergibt   die   Shell   diesem   in   der
Environment-Variablen  _HELP_ADR  die  Adresse  eines  Pointers  auf  die
geladene  Hilfsdatei.  Auf diese Weise kann eine Subshell auf die bereits
geladene  Datei  zugreifen,  ohne diese selber laden zu mssen (was einen
nicht unerheblichen Aufwand an Speicherplatz bedeuten wrde.) 
Die  Shell liest den Inhalt von _HELP_ADR direkt nach der Initialisierung
der  Variablen  aus  dem  Environment und l”scht danach die Shellvariable
_HELP_ADR.  Beim  Aufruf  weiterer  Programme  wird  diese  Variable  nur
w„hrend  der  Erstellung des Environments fr das neue Programm angelegt.
Die  Variable  _HELP_ADR  ist  also  fr  den  Anwender der Shell niemals
sichtbar, befindet sich aber im Environment aller gestarteten Programme. 
Fr  die šbergabe ist es notwendig,  da noch mindestens ein Platz in der
Variablentabelle frei ist. 
Das Format von _HELP_ADR ist 
                            0xAAAAA:0xBBBBB 
,   wobei  AAAAA  die  Adresse  eines Pointers ist (hexadezimal).  Dieser
Pointer  zeigt auf den Text der geladenen Datei.  0xBBBBB ist die Adresse
einer internen Indextabelle,  die die Shell zum schnellen Zugriff auf die
geladenen Daten benutzt.  Diese Indextabelle ist ein Array von Strukturen
des Typs 
        struct
        {
          char Name[12];
          long Offset;
        } HelpIdxTyp;

`Name'  ist der Name eines Kommandos und `Offset' ist die Byte-Entfernung
der  Erkl„rung  dieses Kommandos von dem Beginn des Textes (der durch den
Zeiger  in  der Adresse 0xAAAAA angegeben wird).  Das Ende dieser Tabelle
ist durch einen Eintrag mit Offset=-1L markiert. 
Die angelegte Indexdatei stellt ebendiesen Array dar. 
(0xAAAAA   ist   also  vom  Typ  (char  **),   w„hrend  0xBBBBB  vom  Typ
(HelpIdxTyp*)  ist.)  ACHTUNG: auf keinen Fall darf der Pointer ver„ndert
werden. 



b) Von der Standardeingabe

Wenn  das  Flag L nicht gesetzt ist,  ist der Zeileneditor ausgeschaltet,
und die Shell liest Kommandos von der Standardeingabe.  Das bedeutet, da
weder   die   Editierfunktionen   noch   die   sonstigen  Funktionen  des
Zeileneditors,  wie Filename Completion,  Fileselect-Box, Help-Taste usw.
zur  Verfgung  stehen.   Der Sinn dieses Modus ist,  Kommandos von etwas
anderem als der Tastatur,  z.B. von einer Schnittstelle, einer Datei oder
einer Pipe, einzulesen. 
Um  den  Zeileneditor schon beim Start der Shell auszuschalten,  mu beim
Start  von sh.ttp das Flag -L angegeben werden.  Innerhalb der Shell kann
dieselbe Wirkung durch Eingabe von "set -L" erreicht werden. Mit "set +L"
wird der Zeileneditor wieder eingeschaltet. 
Wenn der Zeileneditor abgeschaltet ist,  kann die Shell nur durch Eingabe
von "exit" oder durch Druck auf Ctrl-Z beendet werden. 



c) Aus einer Datei

Es ist m”glich,  Dateien zu schreiben,  die Shell-Kommandos enthalten und
diese  Dateien  Kommando  fr Kommando von der Shell ausfhren zu lassen.
Solche  Dateien  werden  als  Shell-Scripts  (oder in der MS-DOS-Welt als
Batch-Dateien)   bezeichnet.   Ein  Shell-Script  kann  wiederum  weitere
Scripts  ausfhren  usw.,  wobei die Tiefe der Schachtelung durch den zur
Verfgung  stehenden  Speicher begrenzt ist.  Rekursive Shellscripts sind
natrlich auch m”glich. 
Fr  die  Kommandos  in  Shell-Scripts  gelten  dieselben  Regeln wie fr
Kommandos, die ber die Tastatur eingegeben werden. 
Wenn  MiNT installiert und das Shell-Flag -r gesetzt ist,  dann fhrt die
Shell  jedes  Shellscript in einer Subshell aus,  d.h.  die Shell kopiert
sich  selber,   und  die  Kopie  fhrt  das Shellscript aus.  Das hat den
Vorteil,   das Scripts set-Einstellungen,  Variablen usw.  „ndern k”nnen,
ohne  diese  nachher wiederherstellen zu mssen.  Wer wenig Speicher hat,
sollte auf diese M”glichkeit allerdings besser verzichten. 
Da  das Script in einer Kopie der aktuellen Shell ausgefhrt ist,  findet
es  dieselbe  Arbeitsumgebung  wie  diese Shell,  d.h.  insbesondere alle
Shellvariablen, auch wenn diese nicht exportiert sind. 
Ohne  MiNT  oder wenn das Shell-Flag -r nicht gesetzt ist fhrt die Shell
alle Shellscripts selber aus.  Das bedeutet, da das Script Variablen und
sonstige Einstellungen in der ausfhrenden Shell ver„ndern kann. 

Bei der Ausfhrung eines Shellscripts wird das Script erst vollst„ndig in
den  Speicher  geladen  und  dann  im  Speicher  ausgefhrt.  Das liefert
besonders      bei     der     Ausfhrung     von     Diskette     enorme
Geschwindigkeitsvorteile. 

Bei  Shellscripts  gibt es die M”glichkeit,  Programmierstrukturen wie if
und while zu benutzen,  die bei Tastatureingabe wenig Sinn machen.  Damit
ist  es  in  der  Tat  m”glich,   Shellscripts zu schreiben,  die wie ein
Programm einer h”heren Programmiersprache laufen. Siehe hierzu showpic.sh
und commands.doc. 

Es gibt vier Arten von Kommandos: 
        1) interne Kommandos,
        2) externe Kommandos,
        3) Shellfunktionen,
        4) Kommentare.



INTERNE KOMMANDOS

Ein internes Kommando ist ein Kommando, durch das eine Funktion innerhalb
der Shell ausgefhrt wird,  das also in der Shell eingebaut ist.  Interne
Kommandos werden durch Eingabe ihres Namens aufgerufen. 
Genaue  Erkl„rungen  aller  interner Kommandos befinden sich in der Datei
commands.doc. 


EXTERNE KOMMANDOS

Ein externes Kommando ist nicht in der Shell eingebaut,  sondern in einer
Datei auf einer Diskette, Ramdisk oder Festplatte vorhanden. Hierbei kann
es  sich sowohl um eine ausfhrbare Datei (.PRG,  .TOS etc.)  als auch um
ein Shellscript handeln. 
Externe  Kommandos  k”nnen durch Eingabe des vollst„ndigen Pfadnamens der
entsprechenden  Datei,   aber  auch durch Eingabe des Kommandonamens (des
Dateinamens  ohne  Pfad  und Extender)  gestartet werden.  Die zugeh”rige
Datei  wird  auf  den  Pfaden  gesucht,   die in der Shell-Variablen PATH
gespeichert sind. 
Mit  dem hash-Kommando kann der Pfad eines Kommandos der Shell mitgeteilt
werden, ohne da er in $PATH enthalten ist. 
Externe  Kommandos k”nnen nur ausgefhrt werden,  wenn ihr Datei-Extender
einem  der in den Shell-Variablen XEXT und SEXT gespeicherten entspricht.
(Es  kann  jedoch  jede  Datei,  unabh„ngig vom Dateinamen,  explizit als
Shellscript   oder  Bin„rdatei  ausgefhrt  werden,   und  zwar  mit  den
Kommandos `.'  und `exec'.)  Siehe hierzu auch den Abschnitt ber externe
Kommandos in commands.doc. 

Externen   Programmen   werden  die  Parameter  nach  dem  xArg-Verfahren
bergeben,   wenn das Shell-Flag `a'  gesetzt ist (siehe commands.doc zum
Thema   `set').    Dies  erm”glicht  die  šbergabe  von  beliebig  vielen
Parametern, w„hrend Gemdos die Parameter auf 125 Zeichen beschr„nkt. 
Achtung:  einige (wenige) Programme vertragen sich damit nicht und laufen
nur,  wenn die xArg-šbergabe mit `set -a'  unterbunden wird.  Dazu geh”rt
z.B. der Entpacker `unzip'. 

Wenn der Aufruf eines externen Kommandos von einem `&' gefolgt ist, z.B. 

                    c:/mint/getty.ttp u:/dev/tty1 & 

, dann wird das Programm als Hintergrundproze gestartet, die Shell l„uft
also   weiter,    w„hrend  das  Programm  l„uft.   Die  Prozenummer  des
Hintergrundprozesses wird auf dem Bildschirm ausgegeben. 
Die  Standardausgabe  des Programmes wird dadurch nicht umgeleitet,  d.h.
wenn   ein  Hintergrundproze  Ausgaben  macht,   dann  erscheinen  diese
ebenfalls  auf  dem  Bildschirm  und vermischen sich ggfs.  mit denen der
Shell.   Daher  sollte  beim  Aufruf eines Hintergrundprozesses immer die
Ausgabe umgeleitet werden, notfalls nach NULL: (oder u:/dev/null). 



SHELLFUNKTIONEN

Shellfunktionen  sind  Shellscripts,   die  resident im Speicher gehalten
werden.   Sie  haben  dieselben Eigenschaften wie Shellscripts und k”nnen
deshalb auch genauso programmiert werden.  Alles, was ber die Verwendung
von Shellscripts gesagt wird, gilt auch fr Shellfunktionen. 
Jede  Shellfunktion  hat  einen  Namen,   der bis zu 80 Zeichen lang sein
darf.  Gro-  und Kleinschreibung wird unterschieden,  d.h.  "hallo"  und
"Hallo" sind zwei verschiedene Shellfunktionen. 
Bei  der  Ausfhrung haben Funktionen die oberste Priorit„t,  kommen also
noch vor den internen Kommandos.  Es ist also m”glich,  interne Kommandos
umzudefinieren,  indem man eine Shellfunktion mit demselben Namen anlegt.
Innerhalb   dieser   Funktion   kann   auf   das  ursprngliche  Kommando
zugegriffen  werden,   indem  man  dem  Kommando ein Ausrufezeichen (ohne
Leerzeichen) vorstellt. 

Die Syntax einer Deklaration von Shellfunktionen ist: 

        [Funktionsname] "(" Dateiname ")"               (1)


                oder


        Funktionsname "()"                              (2)
        "{"
          {Zeilen des Funktionsrumpfes}
        "}"


                oder


        Funktionsname "()"                              (3)
        "{}"

(1) In  der  ersten  Fassung wird die angegebene Datei als Shellscript in
den  Speicher  geladen  und  unter  dem Namen der Funktion abgespeichert.
Wenn kein Funktionsname angegeben ist, wird der Basisname des Dateinamens
(ohne Extender)  als Funktionsname benutzt.  In dieser Fassung entspricht
die Shellfunktion also einem speicherresidenten Shellscript. 
Wenn  die angegebene Datei eine ausfhrbare Programmdatei ist,  wenn also
ihr  erstes  Wort  0x601a  ist,   wird  das  Programm  geladen  und  eine
Shellfunktion erzeugt,  die das Programm mit `exec -x' startet. Auf diese
Weise ist es m”glich,  auch Bin„rprogramme resident im Speicher zu halten
und ohne Disketten- oder Plattenzugriffe beliebig oft zu starten. 
ACHTUNG:    Die   Vorgehensweise  dabei  beruht  auf  der  F„higkeit  der
Gemdos-Funktion Pexec, Bin„rprogramme zu laden und erst zu einem sp„teren
Zeitpunkt unter Angabe der Basepage-Adresse zu starten. Die Dokumentation
von Atari zu diesem Feature ist kurz und eindeutig;  sie lautet:  "Finger
davon".   Nichtsdestoweniger  funktioniert  es,  aber  es  besteht  keine
Garantie,     da    es    immer   oder   mit   allen   Programmen   oder
Betriebssystemversionen funktioniert. 

(2) In  der  zweiten  Fassung wird die Funktion von der Tastatur oder dem
Shellscript,   in dem die Deklaration steht,  gelesen.  Wenn bereits eine
Funktion mit dem angegebenen Namen existiert, wird sie umdefiniert. 
Wenn  der Funktionsrumpf leer ist,  wenn also die Zeilen mit `{'  und `}'
direkt aufeinander folgen, wird die Funktion gel”scht. 
In   dieser   Fassung  wird  die  Eingabe  verkrzt,   d.h.   Leerzeilen,
Kommentarzeilen und fhrende Leerzeichen werden nicht mit abgespeichert. 

(3) In der dritten Fassung wird die Funktion gel”scht.  Das geht auch mit
dem Kommando `unset Funktionsname'. 

Die  zweite  und  dritte  Fassung erwarten also mehr als eine Zeile.  Die
weiteren  Zeilen  der  Deklaration werden von der sog.  "Sekund„reingabe"
erwartet,   also  von  dem  Ger„t oder der Datei,  von der augenblicklich
Kommandos gelesen werden (das ist nicht immer die Standardeingabe).  Wenn
es  sich  dabei um die Tastatur handelt,  erscheint als Prompt der Inhalt
der Shellvariablen PS2. 

ACHTUNG:   In  keinem Fall darf zwischen Funktionsname und der ge”ffneten
Klammer ein Leerzeichen stehen. 

Beispiele: 


hallo(hallo.sh)

   initialisiert  eine Funktion namens "hallo".  Die Funktion entspricht
   dem Shellscript hallo.sh. 


hallo (hallo.sh)

   ruft  das Kommando hallo mit dem Parameter (hallo.sh)  auf,  ist also
   KEINE   Deklaration  einer  Shellfunktion.   (Schuld  daran  ist  das
   Leerzeichen nach "hallo".) 


(c:/bin/test.sh)

   initialisiert  eine  Funktion  aus der Datei c:/bin/test.sh.  Da kein
   Funktionsname  angegeben  ist,  wird der Basisname der Datei benutzt,
   es  wird  also die Shellfunktion "test"  erzeugt.  (Nebenbei bemerkt:
   dadurch wird das interne Kommando "test" umdefiniert.) 


(c:/bin/hallo.prg)

   l„dt  das  Programm  hallo.prg  und erzeugt eine Shellfunktion namens
   hallo,  die das geladene Programm startet.  hallo hat dabei folgenden
   Funktionsrumpf: 
                  exec -lg c:/bin/hallo.prg 0xnnnn 
   wobei  nnnn  die  beim  Laden  ermittelte  Adresse  der  Basepage von
   hallo.prg ist (hexadezimal). 

hallo()
{
  echo Hallo, wie gehts?
  read _
  echo Es freut mich, da es Dir $_ geht.
  unset _
}

   definiert  die  Funktion `hallo'  mit dem angegebenen Funktionsrumpf.
   Die  Verwendung  von Shellvariablen ist m”glich;  in diesem Fall wird
   die Variable _ (Underscore)  benutzt,  die fr tempor„re Verwendungen
   zur   Verfgung  steht.   Diese  Deklaration  kann  sowohl  in  einem
   Shellscript stehen als auch ber die Tastatur eingegeben werden.  Bei
   Tastatureingabe erscheint das Prompt $PS2. 

ls()
{
  !ls -C $*
}

   Das interne Kommando ls wird so umdefiniert,  da die Option -C immer
   aktiv  ist.   Dies geschieht durch Definition einer Shellfunktion mit
   Namen ls, die das interne Kommando durch !ls aufruft. 


alias ls !ls -C

   hat dieselbe Wirkung. 

hallo()
{}

   Die Shellfunktion hallo wird gel”scht. 

hallo()
{
}

   Dito. 


unset hallo

   Dito. 


()

   (weder Funktions- noch Dateiname angegeben) ist ein Syntaxfehler. 

Mit   dem   internen   Kommando   "fcts"    kann  eine  Liste  s„mtlicher
Shellfunktionen   erzeugt   werden.    Die  Definition  einer  beliebigen
Shellfunktion  kann  mit  dem  Kommando "type"  ausgegeben werden.  Siehe
hierzu commands.doc. 

Es  geh”rt zur Philosophie von Unix,  da man an der reinen Eingabe nicht
erkennen  kann,  ob es sich bei dem eingegebenen Kommando um ein internes
Kommando, eine ausfhrbare Datei, ein Shellscript oder eine Shellfunktion
handelt.   Um  das  herauszufinden,  gibt es das interne Kommando `type'.
Siehe hierzu commands.doc. 


KOMMENTARE

Eine  Eingabe  gilt  als  Kommentar,   wenn sie mit einem Doppelkreuz (#)
beginnt  oder  wenn  sie  nur aus einer leeren Zeile besteht.  Kommentare
werden  von  der  Shell  nicht  weiter  beachtet  und  sind  ntzlich zum
Dokumentieren  von Shellscripts.  Die Tastatureingabe von Kommentaren ist
zwar m”glich, aber nicht unbedingt sinnvoll. 
--------------------------------------------------------------------- 


ERWEITERTE WILDCARDS

Die   Okami-Shell   erlaubt   fr   die   Angabe   von   Dateinamen   ein
Wildcard-System,  das weit ber das von Gemdos gestellte hinausgeht.  Die
einzigen Gemdos-Wildcards sind * und ?, wobei ein ein Dateiname nur einen
Stern  enthalten  darf,  und den nur am Ende von Name oder Extender.  Bei
"**"   gibt  es Probleme,  "*hallo*"  liefert nicht alle Dateinamen,  die
"hallo" enthalten usw. 
Die erweiterten Wildcards der Okami-Shell orientieren sich an denen,  die
von der Original-Unix-Shell zur Verfgung gestellt werden. Es bedeuten: 
*               beliebig viele, auch null, beliebige Zeichen.
?               genau ein beliebiges Zeichen.
[abcd]          genau ein Zeichen, und zwar eins der in den Klammern ste-
                henden. Es drfen beliebig viele Zeichen angefhrt sein.
[a-g]           genau ein Zeichen, und zwar a, b, ... oder g. Das Minuszei-
                chen bedeutet also "bis".
[~abc]          genau ein Zeichen, und zwar ein beliebiges bis auf die Zei-
                chen in den eckigen Klammern. Es drfen beliebig viele Zei-
                chen angefhrt sein.


Der Punkt zwischen Dateiname und Extender wird dabei wie jedes andere
Zeichen behandelt, "*" pat also auf alle Dateinamen und nicht nur auf
die ohne Extender.


Beispiele:



*               alle Dateinamen.
*.*             alle Dateinamen, die einen Extender haben.
*.?             alle Dateinamen, deren Extender aus genau einem Zei-
                chen besteht.
*.[co]          alle Dateinamen mit Extender .c oder .o.
*.[~co]         alle Dateinamen auer denen mit Extender .c und .o.
[abcd]*[xyz]    alle Dateinamen, deren erstes Zeichen a, b, c oder
                d und deren letztes Zeichen x, y oder z ist. Der
                Punkt, der den Extender einleitet (falls vorhanden), kann
                irgendwo dazwischen stehen.
a[0-9]          alle Dateinamen, die aus a, gefolgt von einer Ziffer be-
                stehen, also a0, a1, ..., a9.
??[a-z][0-9]    alle Dateinamen, die aus zwei beliebigen Zeichen,
                gefolgt von einem Buchstaben und einer Ziffer bestehen.

Wenn  das Shell-Flag w nicht gesetzt ist,  sind die erweiterten Wildcards
auer  Kraft gesetzt.  Die Shell benutzt dann nur die Wildcards,  die von
TOS zur Verfgung gestellt werden. 

Das  Programm fr den Vergleich mit erweiterten Wildcards stammt von Rich
Salz und wurde 1986 geschrieben. 

---------------------------------------------------------------------------



FLAGS UND PARAMETER

Jedem  Kommando  k”nnen  Flags  und  Parameter  bergeben werden.  I.d.R.
werden Parameter benutzt,  um festzulegen, womit etwas getan werden soll,
und die Flags legen fest, wie es getan werden soll. 

Die Shell teilt die Eingabezeile in Worte auf.  Worte werden durch White-
space-Zeichen (Leerzeichen,  Tab,  Formfeed) getrennt. Durch doppelte (")
oder  einfache  (')   Anfhrungszeichen k”nnen auch Whitespace-Zeichen in
Worten benutzt werden, z.B. ist 
                                a b c d 
vier Worte, w„hrend 
                               "a b c d" 
nur  ein  Wort  ist.  Einfache Anfhrungszeichen verhindern auerdem jede
Art  von Interpretation,  d.h.  innerhalb von einfachen Anfhrungszeichen
werden 
        * keine Shellvariablen expandiert
        * keine Slashes zu Backslash umgeformt
        * keine Escape-Sequenzen (beginnent mit ^) interpretiert
        * keine Command-Substitution ausgefhrt

                                 $HOME 
den Inhalt der Shell-Variablen HOME und 
                                '$HOME' 
den String $HOME. 

Externen  Kommandos  werden  alle  bergebenen  Flags  und  Parameter als
Kommandozeile  bergeben.   Alle  exportierten Shell-Variablen werden den
externen Kommandos im Environment bergeben. Das Betriebssystem limitiert
die  L„nge  der  Kommandozeile auf maximal 125 Zeichen.  Die šbergabe von
mehr Zeichen ist durch das xArg-Protokoll m”glich. Die Flags der internen
Kommandos werden i.d.R. durch ein Minuszeichen eingeleitet. N„heres siehe
commands.doc. 

Die  Shell  benutzt  eine Reihe eigener Flags,  die mit dem internen Kom-
mando set eingestellt werden k”nnen. Siehe hierzu commands.doc. 

----------------------------------------------------------------------------



VERKETTETE KOMMANDOS

Kommandos  k”nnen  in  einer  Zeile  durch  Semikolon  getrennt angefhrt
werden. Die Kommandos werden von links nach rechts ausgefhrt. 

Wenn eine eingegebene Zeile mit einem Dach (^)  endet,  wird anstelle des
Daches die Fortsetzung der Zeile von der Sekund„reingabe eingelesen.  Das
entspricht  dem Backslash in Unix.  (In TOS ist der Backslash zum Trennen
von Datei- und Ordnernamen reserviert.) 
Beispiel: 
ec^
ho ha^
l^
lo
entspricht  "echo  hallo".  Dabei  kann  diese  Eingabe  sowohl  von  der
Tastatur als auch aus einem Shellscript oder einer Shellfunktion stammen.


----------------------------------------------------------------------------



SHELLVARIABLEN

Eine  besondere  Art von internem Kommando ist die Zuweisung eines Wertes
an  eine  Shellvariable.   Alle Shellvariablen sind Stringvariablen.  Der
Name  einer  Shellvariablen  kann  in  beliebiger Reihenfolge Buchstaben,
Ziffern und Underscores (_) enthalten. 

Es k”nnen bis zu 200 Variablen angelegt werden; wer damit nicht auskommt,
benutze  den  Software-Support,   um  eine Version der Shell mit gr”eren
Kapazit„ten  zu  erhalten.   Die  Maximalanzahl der Variablen einer Shell
kann mit "ver -l" ermittelt werden. 

Jede Shell-Variable hat einen Status,  der aus beliebigen (auch null) der
folgenden Eigenschaften besteht: 


USR (User)

   Die Variable wurde vom Benutzer angelegt oder ver„ndert. 


SYS (System)

   Es  handelt sich um eine Systemvariable,  die von der Shell verwaltet
   wird.  Hierzu geh”ren z.B.  die Positionsparameter $0,  $1..., $#, $?
   usw. 


R/O (Read-Only)

   Der  Wert  der  Variablen  darf nicht ver„ndert und die Variable darf
   nicht gel”scht werden. 


EXP (Exportiert)

   Die Variable befindet sich im Environment. 

Die  Eigenschaften  USR  und  SYS  k”nnen  nicht  beeinflut werden.  Die
Eigenschaften  R/O  und  EXP  k”nnen  mit  den  Kommandos `readonly'  und
`export' gesetzt und gel”scht werden. Siehe hierzu commands.doc. 

DEKLARATION 

Shell-Variablen brauchen nicht deklariert zu werden. 

ZUWEISUNG 

Die  Zuweisung  eines  Wertes an eine Shell-Variable geschieht durch eine
Eingabe der Form 
                             Variable=Wert 
z.B.: 
                            NAME=Okami-Shell 

Es wird der String "Okami-Shell"  der Shellvariablen NAME zugewiesen.  In
Unix  ist es blich,  Shell-Variablen in Grobuchstaben zu schreiben,  es
sind  allerdings  auch  Kleinbuchstaben m”glich.  NAME und Name sind zwei
unterschiedliche  Variablen.  Auf die folgende Weise kann einer Variablen
ein leerer Wert zugewiesen werden: 
                              Variable="" 
Der  Wert  der  Variablen  wird  also gel”scht,  aber die Variable selber
bleibt bestehen. 

Auerdem  k”nnen  die  internes  Kommandos "read",  "fsel",  "alert"  und
"mouse"   zur  Zuweisung  von  Eingaben an Shellvariablen benutzt werden.
Siehe hierzu commands.doc. 

BENUTZUNG 

Der  Wert einer Shell-Variablen kann durch Angabe des Variablennamens mit
vorgestelltem Dollar-Zeichen angegeben werden.  In einer Eingabezeile der
Shell  werden  erst alle Variablen zu den betreffenden Werten expandiert,
bevor die Zeile ausgefhrt wird.  Shell-Variablen,  an die noch kein Wert
zugewiesen wurde, werden als Leerstrings behandelt. 
Beispiele:


        NAME=Okami-Shell
        echo $NAME


erzeugt die Ausgabe "Okami-Shell".


        NAME=Okami-Shell
        echo Der Name ist $NAME und nicht anders.


erzeugt die Ausgabe "Der Name ist Okami-Shell und nicht anders."


        VAR1=$VAR2


weist der Variablen VAR1 den Wert der Variablen VAR2 zu.


        VAR1=VAR2
        VAR3=VAR1
        $VAR1=$VAR3


weist der Variablen VAR2 den String VAR1 zu (sic).




Es ist auch m”glich, Shell-Kommandos an Variablen zuzuweisen und dann
ausfhren zu lassen:


        CC=c:\compiler\cc.ttp
        $CC test.c


ruft das Programm c:\compiler\cc.ttp mit dem Parameter test.c auf.

L™SCHEN 

Auf die folgende Weise werden Variablen gel”scht: 
                               Variable= 
Dies ist nicht zu verwechseln mit dem L”schen des Inhalts einer Variablen
(siehe oben).  Wenn hinter dem Gleichheitszeichen nichts steht,  wird die
Variable  vollst„ndig gel”scht und belegt danach keinen Platz mehr in der
Variablentabelle. 
Dies  ist  notwendig,   da  die  Shell nur ber eine begrenzte Anzahl von
Variablen  verfgt.   Besonders  Shell-Scripts,  die Variablen fr lokale
Zwecke  benutzen,   sollten  diese  Variablen  nach  der Benutzung wieder
freigeben. Shellvariablen k”nnen auerdem mit dem Kommando unset gel”scht
werden. 
Beim  L”schen  verliert die Variable natrlich auch ihren Status.  Um den
Status  zu  erhalten,   darf  nur  der Wert der Variablen gel”scht werden
(NAME=""). 

Beispiele: 


NAME=

   Die Shell-Variable NAME wird gel”scht. 


unset NAME

   Ebenso. 

SAVECWD=$CWD
cd c:\work\test
.......................(weitere Kommandos)
cd $SAVECWD

   Das aktuelle Verzeichnis (das stets in der Variablen CWD steht)  wird
   in  der  Variablen  SAVECWD  gesichert.   Danach  wird  das  aktuelle
   Verzeichnis ge„ndert (mit dem internen Kommando "cd"),  und es werden
   weitere   Kommandos   ausgefhrt.   Anschlieend  wird  das  aktuelle
   Verzeichnis wieder restauriert. 
   Diese  Technik sollte von allen Shellscripts benutzt werden,  die das
   aktuelle Verzeichnis „ndern. Unter Unix werden Shellscripts stets von
   Subshells   ausgefhrt,    und  das  aktuelle  Verzeichnis  ist  eine
   Eigenschaft  eines  Prozesses,  weswegen  Shellscripts  das  aktuelle
   Verzeichnis   „ndern  k”nnen,   ohne  das  aktuelle  Verzeichnis  der
   aufrufenden  Shell  zu  beeinflussen.   Die Okami-Shell benutzt keine
   Subshells, und daher kann jedes Shell script das aktuelle Verzeichnis
   der  Shell  „ndern,   was  in  der  praktischen Anwendung nicht immer
   erwnscht ist. 
   Das   umst„ndliche   Speichern   und   Restaurieren   des   aktuellen
   Verzeichnisses  entf„llt,  wenn die Shell-Flags x und c gesetzt sind.
   Siehe hierzu das interne Kommando `set' in commands.doc. 


SYSTEMVARIABLEN 

Eine  Reihe  von  Shellvariablen werden von der Shell selber angelegt und
benutzt.  Es ist teilweise m”glich,  die Werte dieser Variablen zu ver„n-
dern. Diese sind: 


OKSH_PROFILE

   Das  beim  Start der Shell zu landende Profile.  Mu folglich bereits
   beim  Start der Shell im Environment vorhanden sein und hat von da an
   keine Bedeutung fr die Shell mehr. 


PS1

   Das   Eingabeprompt.    Kann   vom  Anwender  ver„ndert  werden  (was
   normalerweise im Profile geschieht). Der Defaultwert ist " $ ". 


PS2

   Das  sekund„re  Eingabeprompt.   Erscheint  z.B.  bei der Eingabe von
   Shellfunktionen.  Kann beliebig ver„ndert werden, der Defaultwert ist
   "> ". 


OKAMISHELL

   Die Versionsnummer der Shell. Kann nicht ver„ndert werden. 
   Diese  Variable  wird nicht an gestartete Programme weitergegeben und
   ist  deshalb  nur  in  Shellscripts  gesetzt,   wenn  diese unter der
   Okami-Shell  laufen.   Daher  kann das Vorhandensein dieser Variablen
   als  Test  benutzt werden,  ob ein Shellscript unter der Okami-  oder
   einer anderen Shell ausgefhrt wird. 


TERM

   Der  Rechnertyp,  wird anhand des _MCH-Cookies eingestellt und ist je
   nachdem  "Atari ST",  "Atari Mega ST",  "Atari STE"  oder "Atari TT".
   Wenn   kein   Cookie-Jar  installiert  ist,   wenn  kein  _MCH-Cookie
   vorhanden  ist  oder wenn dessen Wert kleiner als 0 oder gr”er als 3
   ist,  wird "Atari ST"  benutzt.  TERM ist in der jetzigen Version der
   Shell  noch  ohne  weitere Bedeutung,  wird aber von einigen Program-
   men   benutzt,    die  eine  Unix-„hnliche  Termcap  verwenden  (z.B.
   Gnu-Emacs)   und sollte dann auf den entsprechenden,  von der Termcap
   ben”tigten Wert (z.B. "st" oder "vt52") eingestellt werden. 


CWD

   Das aktuelle Verzeichnis.  Wird nach jedem Wechsel des Verzeichnisses
   automatisch  aktualisiert und sollte nicht von Hand ver„ndert werden.
   (Durch   eine   Zuweisung   an   diese  Variable  wird  das  aktuelle
   Verzeichnis nicht ge„ndert.) 


HOME

   Das  Verzeichnis,   aus dem die Shell gestartet wurde (genauer gesagt
   das  aktuelle  Verzeichnis zum Zeitpunkt des Starts der Shell).  Kann
   nach Bedarf ver„ndert werden. 


ETC

   Das Verzeichnis, in dem die Shell Hilfsdateien wie z.B. die Textdatei
   fr das help-Kommando erwartet.  Wird bei Programmstart auf denselben
   Wert wie HOME eingestellt und kann beliebig ver„ndert werden. 


SHELL

   Hier  soll der vollst„ndige Aufrufpfad des Shellprogramms eingetragen
   sein.   Da  die  Shell  diesen  nicht  mit v”lliger Sicherheit selber
   bestimmen  kann,   wird hier $HOME\sh.ttp eingetragen.  Kann beliebig
   angepat werden,  wenn diese Angabe einmal nicht zutrifft. Wird nicht
   von der Shell,  aber von einigen Programmen benutzt (z.B. Micro-Emacs
   oder  Pure  C).   Wer  ein neues Programm schreibt,  sollte die Shell
   lieber ber den _shell_p-Zeiger aufrufen. 


PAGELEN

   Die  Anzahl  der  Zeilen  auf  dem Bildschirm.  Wird von dem internen
   Kommando pg (bzw.  more)  benutzt.  Kann beliebig eingestellt werden.
   Die Defaulteinstellung ist 23. 


PIPDIR

   Das  Laufwerk und der Pfad,  auf dem die Hilfsdateien von Pipelining,
   Command   Substitution   usw.   erzeugt   werden.   Mu   auf   einem
   beschreibbaren  Laufwerk  (am besten auf einer Ramdisk)  liegen.  Die
   Defaulteinstellung ist $HOME. Kann beliebig ver„ndert werden. 


NULL

   Der  Name  des  Ger„tes oder der Datei,  an die die Ausgaben geleitet
   werden,  die zum Null-Ger„t (NULL:) umgeleitet werden. Kann ver„ndert
   werden.  Die Defaulteinstellung ist "PRN:"  (paralelle Schnittstelle)
   oder "u:\dev\null", wenn MiNT installiert ist. 
   Wer MiNT nicht benutzt und einen Drucker hat,  sollte hier eine Datei
   z.B. auf der Ramdisk eintragen. Die Einstellung AUX: fr die serielle
   Schnittstelle  ist  nicht  m”glich,   da  diese Schnittstelle von der
   Standard-Fehlerausgabe belegt ist. 
   (Und   was   lernen   wir   daraus?   So  schnell  wie  m”glich  MiNT
   installieren.) 


PATHSEP

   Die  Zeichen,  die als Trennzeichen in den Variablen PATH,  XEXT usw.
   gelten sollen. Die Voreinstellung ist ",;", was bedeutet, da in PATH
   usw.   einzelne  Felder  mit  Kommata oder Semikolons getrennt werden
   k”nnen.  Wenn in MiNT nur das unifizierte Dateisystem auf Laufwerk U:
   benutzt,   kann  in  PATHSEP  auch  den Doppelpunkt eintragen und die
   Felder in PATH wie in Unix mit Doppelpunkten trennen. 


XEXT

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Extendern.   Dateien  mit einem der hier aufgefhrten Extender k”nnen
   als  Bin„rprogramme  gestartet  werden.  Die  Defaulteinstellung  ist
   ".prg,.tos,.ttp,.app".  Die  Punkte  vor  den  Extendern  mssen  mit
   angegeben werden. Kann beliebig ver„ndert werden. 


SEXT

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Extendern.   Dateien  mit einem der hier aufgefhrten Extender k”nnen
   als Shellscripts gestartet werden.  Die Defaulteinstellung ist ".sh".
   Die  Punkte  vor  den  Extendern  mssen  mit angegeben werden.  Kann
   beliebig ver„ndert werden. 


GEXT

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Extendern.   Bin„rdateien  mit  einem  der hier aufgefhrten Extender
   werden  als  GEM-Programme,  d.h.  nicht  direkt,  sondern  ber  die
   Shellfunktion  gemexec  gestartet.   Siehe  hierzu den Abschnitt ber
   gemexec  in  commands.doc.   Die Defaulteinstellung ist ".prg".  Kann
   beliebig ver„ndert werden. 
   Wie  in  commands.doc  erkl„rt,   mssen die Extender nicht unbedingt
   denen von ausfhrbaren Programmdateien entsprechen. 


MANEXT

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Extendern. Dateien mit einem der hier angefhrten Extender werden von
   der  Online-Hilfe  mit  der  Helptaste  oder  dem  Kommando  man  als
   Anleitungsdateien  erkannt.   Die  Voreinstellung lautet ".doc,.man".
   Kann beliebig ver„ndert werden. 


PATH

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Pfaden.   Bei  der Eingabe eines externen Kommandos ohne vollst„ndige
   Pfadangabe wird die Datei auf den hier angegebenen Pfaden gesucht. 
   Die  Defaulteinstellung  ist  ".,..,$HOME,$HOME\bin".   Kann  beliebg
   ver„ndert werden. 


CDPATH

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Pfaden.   Beim  Wechsel  des aktuellen Arbeitsverzeichnisses mit "cd"
   wird,   wenn  der  bei  cd  angegebene Pfad nicht existiert und nicht
   absolut  angegeben  ist,  auf  den  in  CDPATH  gespeicherten  Pfaden
   gesucht.  Die Defaulteinstellung ist "..,\".  Kann beliebig ver„ndert
   werden. 


MANPATH

   Eine  Liste  von durch die in $PATHSEP angefhrten Zeichen getrennten
   Pfaden.  Auf diesen Pfaden sucht die Online-Hilfe (Helptaste oder das
   Kommando  `man')  nach Anleitungsdateien.  Die Defaulteinstellung ist
   "$HOME\doc". Kann beliebig ver„ndert werden. 


HELPFILE

   Der  Name der Datei,  aus der die Erkl„rungen,  die bei Druck auf die
   Help-Taste  ausgegeben  werden,  stehen.  Die Default einstellung ist
   "$HOME\doc\commands.doc". Kann beliebig ver„ndert werden. 


CLIPDIR

   Enth„lt den Pfad des GEM-Clipboards. Wird durch die Kommandos gon und
   clipb  initalisiert,  die  Voreinstellung  bei  Programmstart  lautet
   "X:\scrapdir\scrap.*",  wobei X: das Bootlaufwerk ist. Diese Variable
   sollte nur mit dem Kommando clipb ver„ndert werden. Siehe hierzu auch
   commands.doc. 

   Enth„lt  bei Eingabe eines Kommandos den Namen des Kommandos und beim
   automatischen  Aufruf der Funktion gemexec den vollst„ndigen Pfad des
   aufzurufenden Programms. 


1

   Enth„lt den ersten Parameter der Eingabezeile. 


2

   Enth„lt den zweiten Parameter der Eingabezeile usw. 


#

   Enth„lt die Anzahl der Parameter der Eingabezeile. 


*

   Enth„lt die vollst„ndige Eingabezeile. 


?

   Enth„lt den Rckgabewert des zuletzt ausgefhrten Kommandos. 

Die  folgenden Shellvariablen werden nur von einzelnen internen Kommandos
benutzt. 


COLUMNS

   von `scr': Anzahl der Zeilen auf dem Bildschirm. 


DIALPREFIX

   fr `dial': Pr„fix des Modem-W„hlkommandos. 

Nach dem Start der Shell werden Variablendefinitionen aus dem Environment
gelesen  und  ausgefhrt.   Auf  diese  Weise k”nnen alle Variablen (auch
LOGNAME usw.) ge„ndert, aber keine gel”scht werden. 

----------------------------------------------------------------------------



EIN/AUSGABE-UMLEITUNG



1) Fr interne Kommandos

Die Eingabe,  Ausgabe und Fehlerausgabe jedes internen Kommandos kann auf
einfache Weise in bzw.  aus einer beliebigen Datei oder zu bzw. von einem
Ger„t umgeleitet werden. 

Folgende Umleitungsm”glichkeiten stehen zur Verfgung: 


<Datei

   Umleitung der Eingabe 


>Datei

   Umleitung der Ausgabe, die Datei wird vorher gel”scht 


>>Datei

   Umleitung der Ausgabe, sie wird an die Datei angeh„ngt 


2>Datei

   Umleitung der Fehlerausgabe, die Datei wird vorher gel”scht 


2>>Datei

   Anh„ngen der Fehlerausgabe an die Datei 

Anstelle von "Datei" k”nnen auch die folgenden Ger„te angegeben sein: 
        CON:            Konsole (Default)
        PRN:            parallele Schnittstelle (Drucker)
        AUX:            serielle RS232-Schnittstelle (Modem)
        NULL:           ignorieren

Das  Ger„t  NULL:,   auch Null-Ger„t genannt (in Unix:  /dev/null),  wird
nicht  vom  Betriebssystem  des  ST  untersttzt,   sondern von der Shell
simuliert.    Der   Zweck  eines  Null-Ger„tes  ist,   die  Ausgabe  oder
Fehlerausgabe  eines  Kommandos zu unterdrcken.  Die Shell-Variable NULL
gibt an, wo die Ausgabe, die an NULL: umgeleitet wird, tats„chlich landen
soll.   Normalerweise  ist  das die Druckerschnittstelle;  wenn diese von
einem  Drucker  belegt ist,  sollte man eine regul„re Datei z.B.  auf der
Ramdisk angeben (NULL=G:/null). 
Wer  MiNT benutzt,  hat damit keine Probleme,  da MiNT ein Null-Ger„t zur
Verfgung  stellt.   Unter  MiNT  sollte  man  NULL  auso auf u:/dev/null
einstellen (was die Shell beim Starten automatisch tut). 

Beispiel: 

                                rm *.dup 

l”scht  s„mtliche  dup-Dateien,   gibt aber eine Fehlermeldung aus,  wenn
keine  solchen  Dateien  vorhanden  sind  oder  wenn sie schreibgeschtzt
sind.   Um  die  Fehlermeldung  zu  unterdrcken,  kann  man  stattdessen
schreiben: 
                            rm *.dup 2>NULL: 

Dadurch   werden   die   Fehlermeldungen   an  das  Null-Ger„t  geleitet.
(Nebenbei: bei Verwendung von 
                              rm -f *.dup 
werden  auch  keine  Fehlermeldungen ausgegeben,  allerdings werden damit
auch schreibgeschtzte Dateien gel”scht.) 

Wenn  keine  Umleitung  angegeben ist,  geht die Eingabe von der Tastatur
und  die Ausgabe und Fehlerausgabe zum Bildschirm,  genauer gesagt zu der
Standard-Ein-   und  -Ausgabe der Shell selber (die beim Start von sh.ttp
angegeben werden kann). 


PIPELINING

Die  Idee des Pipelining ist es,  die Ausgabe eines Kommandos zur Eingabe
des  n„chsten  zu  machen.   So  schreibt  z.B.  das memex-Kommando einen
Speicherbereich  auf  seine  Ausgabe,   und  das  hd-Kommando fertigt von
seiner Eingabe ein Hexdump an.  Mit dem Pipelining k”nnen beide Kommandos
verbunden werden, d.h. man bekommt ein Hexdump eines Speicherauszuges. 
Um  zwei Kommandos in einer Pipeline zu verbinden,  wird zwischen sie ein
senkrechter Strich (|), auch Pipe genannt, gesetzt, z.B.: 

                             hd sh.ttp | pg 

Die  Ausgabe  des hd-Kommandos (ein langer Hexdump)  wird zur Eingabe des
pg-Kommandos,   wodurch  der  Hexdump  seitenweise  angezeigt  wird.  Die
Schreibweise  a | b ist „quivalent zu:  (a und b sind beliebige Kommandos
incl. ihren Parametern) 

        TMP=$PIPDIR\pip$$
        a > $TMP
        chmod +h $TMP
        b < $TMP
        rm $TMP
        unset TMP

(mit  drei  kleinen  Unterschieden:   1.  zum  Bilden  eines  eindeutigen
Dateinamens  wird nicht $$,  sondern ein anderer Z„hler benutzt,  2.  die
Datei wird nach dem Anlegen und nicht erst nach dem Ende von a unsichtbar
gemacht und 3. es wird keine Shellvariable benutzt.) 
Dies  ist  ein  wesentlicher  Unterschied zu Unix,  wo alle an einer Pipe
beteiligten Kommandos (Prozesse)  gleichzeitig laufen.  Eine Pipeline ist
unter Unix eine Einrichtung des Betriebssystems,  die von der Okami-Shell
nur  simuliert  wird.   (Wie  gesagt,  Okami  ist  eine  Shell  und  kein
Betriebssystem.) 

Das  Laufwerk  und  der Ordner,  auf dem die Pipe-Dateien erzeugt werden,
kann   mit   der   Shellvariablen   PIPDIR   eingestellt   werden.    Die
Defaulteinstellung  beim  Start der Shell ist $HOME.  Dadurch bietet sich
die  M”glichkeit,   die Pipe-Dateien auf ein schnelles Laufwerk zu legen,
z.B. auf eine Ramdisk oder eine wenig benutzte Partition der Festplatte. 
VORSICHT:   Wenn  $PIPDIR  auf  einen  nicht  existierenden  Ordner  oder
Laufwerk  eingestellt  ist,  erscheinen anstelle von Pipe-Operationen nur
Fehlermeldungen der Form: 

                     Error: cannot open .....\pip3 

(Anstelle von ...... steht der Inhalt von PIPDIR.) 
In  diesem  Fall  wird  keins  der  an  einer  Pipe beteiligten Kommandos
ausgefhrt. 
Abhilfe schafft das Kommando 

                           mkdir -r $PIPDIR/ 

im  Profile  nach  dem  Einstellen  von  PIPDIR.   Dadurch werden alle zu
$PIPDIR geh”renden Unterverzeichnisse erzeugt. 

Die Pipe-Datei kann mit folgendem Kommando sichtbar gemacht werden: 

                        ls -a $PIPDIR\pip* | cat 


INLINE-DOKUMENTE

Als   Inline-    oder   Hier-Dokument   wird   eine   spezielle  Art  der
Eingabeumleitung  bezeichnet,   bei  der  die einem Kommando zuzufhrende
Eingabe  direkt  von  der  Eingabe  oder  z.B.  dem  Shellscript  stammt.
Beispiel: 

        cat <<eof
        Das ist ein Text, der
        zu der Eingabe des cat-
        Kommandos wird.
        eof

Diese  Zeilen  k”nnen  von  der  Tastatur eingegeben,  aber auch in einem
Shellscript oder einer Shellfunktion stehen. 
Die  Shell betrachtet die Zeichenkette nach "<<"  als Terminierungsstring
und schreibt die nachfolgenden Zeilen in eine Datei, die dann als Eingabe
des  Kommandos  benutzt  wird.  Das Inline-Dokument wird durch eine Zeile
beendet,    die   nur   (bis   auf   fhrende   Leerzeichen)    aus   dem
Terminierungsstring besteht. 
Wenn den << direkt ein Minuszeichen folgt, also z.B. 

                               cat <<-eof 

,   werden  alle  fhrenden  Leerzeichen der Eingabezeilen entfernt.  Das
Minuszeichen geh”rt nicht zu dem Terminierungsstring. 
Die Shell fhrt auf allen eingelesenen Zeilen Variablensubstitutionen und
Command Substitution aus. 

Inline-Dokumente sind sinnvoll in Shellscripts,  die mehrzeilige Ausgaben
erzeugen  sollen,   wodurch  sich  Reihen  von  echo-Kommandos  vermeiden
lassen. 



2) Fr externe Kommandos

Theoretisch funktionieren s„mtliche Ein/Ausgabe-Umleitungen inklusive der
Pipeline  auch  mit  externen  Kommandos.   In der Praxis jedoch erlauben
nicht  alle  Programme  diese  M”glichkeit,   z.B  weil  sie Tastatur und
Bildschirm  direkt ber die entsprechenden Bios-Funktionen (Bconout etc.)
ansprechen,   die sich nicht umleiten lassen.  (Mit MiNT lassen sich auch
solche Programme umleiten.) 
Die Okami-Shell leitet die Ein/Ausgabe auf Gemdos-Basis um, was bedeutet,
da  alle  Programme,  die fr die Ein/Ausgabe Gemdos-Funktionen (Cconout
etc.)   benutzen,   umgeleitet  werden  k”nnen.   C-Programme,   die  die
Standard-Streams stdin und stdout benutzen,  werden normalerweise korrekt
umgeleitet. 
GEM-Programme sind von vornherein gegen jede Art der Umleitung immun,  da
sie den Bildschirm ber den entsprechenden VDI-Ger„tetreiber ansprechen. 

----------------------------------------------------------------------------



COMMAND SUBSTITUTION

Die  Okami-Shell  bietet die M”glichkeit,  die Ausgabe eines Kommandos in
eine Kommandozeile einzubauen.  M”chte man z.B. eine Ausgabe wie "Es sind
...   Bytes frei"  erzeugen,  in die die Anzahl der freien Bytes (die mit
dem  Kommando  mem ermittelt werden kann)  eingebaut sind,  dann kann die
Ausgabe von mem auf folgende Weise in das echo-Kommando eingebaut werden:


                     echo Es sind `mem` Bytes frei. 

Alles,   was in einer Eingabezeile zwischen zwei Accent grave (`)  steht,
wird  als  Kommando betrachtet und ausgefhrt.  Die Ausgabe wird anstelle
der   in   Accent   grave  stehenden  Zeichenkette  in  die  Eingabezeile
eingesetzt. Dieses Verfahren wird als Command Substitution bezeichnet. 
Wenn  die  Ausgabe  des Kommandos ber mehrere Zeilen geht,  wird nur die
erste  Zeile  (also die Ausgabe bis zum ersten Zeilenende)  benutzt.  Als
Zwischenspeicher  fr  die  Ausgabe  des Kommandos wird eine Datei namens
$PIPDIR/csubXXXX  benutzt.   XXXX  ist hierbei eine laufende Nummer,  und
$PIPDIR  ist  das  Laufwerk,   ber das auch die Pipelining-  Operationen
laufen. Diese Datei wird nach Verwendung gel”scht. 

Beispiele: 

Speichern der Shellflags: 

                              SET=`set -` 

Wiederherstellen mit: 

                                set $SET 

Anzeigen einer Datei,  die in demselben Ordner liegt wie $FILE1, die aber
denselben Basisnamen wie $FILE2 hat: 

                 cat `dirname $FILE1`/`basename $FILE2` 

L”schen der „ltesten Datei mit Nachfrage: 

                             rm -i `ls -t` 

----------------------------------------------------------------------------



ENVIRONMENT

Die Okami-Shell bietet die M”glichkeit,  Definitionen von Shell-Variablen
in  das  Environment zu bernehmen.  Diese Definitionen werden dann allen
gestarteten  Programmen  bergeben.  Mit  dem  internen  Kommando  export
k”nnen  beliebige  Shellvariablen  in  das  Environment  ausgenommen oder
daraus entfernt werden. 

In  der  Basepage  eines  Programms  steht ab Offset 0x2c die Adresse des
Environment-Strings. Diese Adresse wird berechnet als: 

        char *BaseAdr;
        char *EnvAdr;
        EnvAdr = *(char **)(BaseAdr+0x2c);

BaseAdr  ist  die  Adresse  der Basepage (wird irgendwie vom Compiler zur
Verfgung gestellt). EnvAdr ist dann die Adresse des Environment-Strings.
Dieser String hat folgende Syntax: 

        EnvString       ::=  { VarDefinition } "\0"
        VarDefinition   ::= VarName "=" VarWert "\0"

Beispiel: 

           "a=Variable a\0b=Variable b\0usw=undsoweiter\0\0" 

Es werden folgende Variablen gesetzt: 
        a   auf  "Variable a"
        b   auf  "Variable b"
        usw auf  "undsoweiter"


----------------------------------------------------------------------------



MINT-UNTERSTšTZUNG

Die     Okami-Shell     benutzt     und     untersttzt     MiNT,     das
Multitasking-Betriebssystem  fr TOS-Rechner.  Wenn MiNT installiert ist,
dann: 

   * meldet die Shell sich als MiNT-Domain-Prozess an. 

   * wird die Shellvariable NULL als u:/dev/null voreingestellt. 

   * wird die MiNT-Signalverarbeitung verwendet.  Es k”nnen dann interne
   Kommandos  mit  Ctrl-C abgebrochen werden.  Mit Ctrl-\ wird die Shell
   abgebrochen. 

   * k”nnen mit `&' Hintergrundprozesse gestartet werden. 

   * wird  die Tastatureingabe des Zeileneditors mit Fselect abgewicklt,
   d.h. die Shell ben”tigt w„hrend der Eingabe praktisch keine CPU-Zeit.


   * liefert  das Kommando `ps'  eine formatierte Ausgabe der Dateien in
   u:/proc. 

   * liefert das Kommando `time' zus„tzlich User- und Kernalzeiten. 

   * benutzt   das   Kommando  `sleep'   keine  Warteschleife,   sondern
   Systemaufrufe, um w„hrend des Wartens keine CPU-Zeit zu ben”tigen. 

   * beendet das Kommando `shutdown'  alle Prozesse, bevor es das System
   abschaltbereit erkl„rt. 

   * kann mit dem Kommando `ver -m' die Versionsnummer des installierten
   MiNT ermittelt werden. 

   * sind die folgenden Kommandos und Optionen nutzbar: 
           id      User- und Gruppennummer ermitteln
           kill    Signale an Prozesse senden
           ln      Links erzeugen
           ls -s   symbolische Links anzeigen
           tty     Terminalnamen ermitteln


----------------------------------------------------------------------------



GRšSSE

1) An  die  Firma  GRP in Aachen,  fr lebenswichtige Kenntnisse in C und
Unix. 

2) Fr  die Begleitung in zahllosen Stunden voller Lust und Frust vor der
flimmerfreien Flimmerkiste:  Mike Oldfield,  The Beatles, Little Richard,
Bill  Haley,  Tommy Roe,  Lesley Gore,  Pat Boone,  Elvis Presley,  Chuck
Berry,  Del Shannon,  Chris Montez,  Billy Joe Royal,  The Box Tops,  The
Cascades,  Trini Lopez, Chris Andrews, Mary Hopkins, The Tremoloes, Bobby
Vee,  The Kinks, The Turtles, The Swinging Blue Jeans, Shane Fenton & The
Fentones,  The Piltdown Men,  Helen Shapiro, Cliff Richard, The Cowsills,
Jerry  Lee  Lewis,  Melanie,  Buddy  Hollie,  The  Lovin'  Spoonful,  The
Crystals, The Knickerbockers, The Crests, Every Mother's Son, The Shangri
Las, Bernard Cribbins, The Shadows, Frank Ilfield u.v.a. 









Atari ST,  GEM,  Unix, MS-Dumpf usw. sind eingetragene Warenzeichen von -
ach das wit Ihr schon? Na gut. 

Diese  Anleitung  wurde  ursprnglich  als reine Ascii-Datei geschrieben,
dann   in  eine  Tempus-Word-Datei  umgeformt  und  wegen  der  absoluten
Unf„higkeit von Tempus Word,  Texte vernnftig formatiert als Ascii-Datei
auszugeben, in nroff umgeschrieben und mit "miniroff" formatiert. 
