
	===============================================

@(#)	  OKAMI SHELL VERSION 1.4 - KURZEINFöHRUNG

	===============================================
			Stand: 19.9.92


	**					**
	**	English readers please read	**
	**	the 'english.doc' file		**
	**					**


Okami-Shell ist eine Unix-Ñhnliche Kommandoshell fÅr alle Atari ST-Rechner.
Vorbild war die Unix-Bourne-Shell.

Sie arbeitet:
	* mit jeder Speicherkonfiguration (auch mit 512KB)
	* mit jeder Bildauflîsung
	* mit Diskette, Ramdisk und Festplatte
	
BeschrÑnkungen:
	* Der Start der Shell von Diskette ist mîglich, aber wegen der
	  geringen Geschwindigkeit wird Ramdisk oder Festplatte empfohlen.
	* Zur Benutzung der Pipe muû mindestens ein Laufwerk beschreibbar
	  sein. Dies muû nicht notwendig das Laufwerk sein, von dem die
	  Shell gestartet wurde.

Zum Starten der Shell:
	* sh.ttp anklicken und als Parameter ein Minuszeichen angeben.
oder:	* msh.prg anklicken.

FÅr Hilfe:
	* "help" oder "cmds -C" eingeben.
	* Die Help-Taste liefert eine Anleitung zu jedem internen Kommando.

Zum Beenden der Shell:
	* "exit" eingeben.
oder:	* Ctrl-D drÅcken.

	
Das wichtigste in KÅrze:
	* Standard-Unix-Kommandos: cat, ls, cd, pwd, cp, mv, rm, rmdir,
	   df, pg, echo, grep, find, chmod, touch, date, mkdir, basename,
	   dirname, time, xargs, backup, if, while, shutdown,...
	* Åber 100 eingebaute Kommandos
	* eingebauter UPN-Rechner mit Åber 80 Funktionen
	* Shell-Variablen setzen in der Form NAME=WERT
	* AusfÅhrung von der Shell als TTP-Parameterzeile Åbergebenen
	  Kommandos mit darauffolgender Beendigung der Shell mîglich
	* Aufruf Åber den _shell_p-Zeiger mîglich, incl. Quellcode der
	  system()-Funktion
	* Konfiguration der Shell durch eine nach Programmstart auszu-
	  fÅhrende Kommandodatei (Profile)
	* Eingabe, Ausgabe und Fehlerausgabe aller interner Kommandos
	  umleitbar mit <, >, >>, 2>, 2>> fÅr alle Programme, die
	  Ein- und Ausgabe auf Gemdos-Basis benutzen
	* Simulation von Pipelining: Die Ausgabe eines Kommandos wird
	  zur Eingabe eines anderen; beliebig schachtelbar
	* Command Substitution: z.B.
	  echo Der Basisname von $FILE ist `basename $FILE`
	* Unix-Wildcards, z.B. a[bcd-f]*e?.[xy]? etc.
	* AusfÅhrung von Shellscripts (Batch-Files) mit ParameterÅbergabe
	* Shellfunktionen = speicherresidente Shellscripts mîglich; Shell-
	  funktionen kînnen interne Kommandos umdefinieren (die ursprÅng-
	  lichen Kommandos kînnen trotzdem noch aufgerufen werden
	* Shellfunktionen kînnen auch mit der Tastatur eingegeben werden
	* BinÑrprogramme kînnen resident gehalten und Åber Shellfunktionen
	  gestartet werden
	* Hash-Tabelle: die Pfade von aufgerufenen Programmen werden gespei-
	  chert und beim nÑchsten Aufruf ohne Suchen gefunden
	* Tastatureingabe mit History (ZurÅckholen vorheriger Eingaben
	  per Tastendruck)
	* Filename Completion und Substitution auf Tastendruck
	* Alle Tasten inkl. F-Tasten frei mit Kommandos belegbar
	* Suchen von Programmen auf konfigurierbaren Pfaden, mit
	  konfigurierbaren Extendern zur Erkennung ausfÅhrbarer
	  Programme
	* Pfadangaben kînnen wie in TOS (z.B. d:\shell\sh.ttp, getrennt mit
	  Backslash) oder Unix (z.B. d:/shell/sh.ttp, getrennt mit Slash)
	  angegeben werden
	* Programmierung mit if und while, schachtelbar
	* Terminal Server: der Rechner kann Åber eine beliebige Schnitt-
	  stelle ferngesteuert werden
	* Eingebauter Terminal-Emulator
	* UnterstÅtzung von OverScan: OverScan kann per Shell-Kommando
	  ein- und ausgeschaltet werden
	* Alle GEM-Programme sind von der Shell aus ausfÅhrbar
	* Online-Help mit SyntaxerklÑrung aus einer editierbaren Datei
	* Help-Taste liefert Anleitung zu jedem Kommando aus der Anleitungs-
	  Datei der Dokumentation (commands.doc, Åber 170 KB)
	* Bildschirmschoner und Uhr auf Tastendruck
	* Auswertung und Einstellung der Environment-Variablen
	* ParameterÅbergabe per xArg mîglich
	* ausfÅhrliche deutsche Dokumentation (>300 KB) mit vielen Beispielen
	* Software-Support bei Fehlern und Fragen, nicht gebunden an
	  die Zahlung von AnerkennungsbeitrÑgen etc.
	und vieles mehr......

Das wichtigste in Beispielen:

	rm test.o		(Lîschen einer Datei)

	cat test.txt		(Anzeige einer Datei)

	cd d:\shell\bin 	(Wechsel des aktuellen Laufwerks und des
				 aktuellen Directories)

	cd ..			(Wechsel ins Parent-Directory des aktuellen
				 Directories)

	ls -ls d:\		(AusfÅhrliche Dateiliste mit Attributen,
				 Dateigrîûe und -Datum, sortiert nach der
				 Dateigrîûe)

	ls -l d:\ >dir.txt	(Umleitung der Ausgabe)

	hd test.prg | pg	(Seitenweise Ausgabe eines Hexdump)

	date >>datum.log	(AnfÅgen des Datums an das Ende einer Datei)

	echo Bitte Name eingeben
	read NAME		(Benutzung von Shellvariablen)
	echo Der Name ist $NAME

	TMPNAME=dat$$.tmp	(Erzeugen eines eindeutigen Dateinamens
				 durch die System-Shellvariable $, deren
				 Wert sich stÑndig Ñndert [in Unix:
				 Prozessnummer])

	PS1='Eingabe >' 	(éndern des Shell-Prompts)	  

	a=`date`		(Einlesen des Datums in die Variable a)
	echo Das Datum ist $a

	grep printf *.c 	(Suchen von "printf" in allen C-Dateien)

	df C: E: F:		(Ausgabe der Plattenbelegungen)

	chmod +hr secret.dat	(Verstecken und SchreibschÅtzen einer Datei)

	help | grep chmod	(Ausgabe der Syntax des Kommandos chmod)

	find d:\ -name test.* -print	(Ausgabe des Pfades aller Dateien namens
				 test.* auf Laufwerk D:)

	pg $HOME\profile	(Seitenweise Ausgabe der Konfigurationsdatei)

	cursor 12		(Setzen der Cursor-Geschwindigkeit)

	mouse x y		(Abfrage der Maus-Koordinaten, Speichern der
				 Werte in den Variablen x und y)

	fsel *.c test.c 	(Auswahl einer Datei mit der Fileselect-Box)

	touch sh.c		(Erneuern des Dateidatums von sh.c)

	cls			(Bildschirm lîschen)

	time test.tos		(Messen der AusfÅhrungszeit eines Programmes
				 auf 1/100 Sekunden genau)

	export TERM		(öbernahme der Variablen TERM ins Environment)

	find d:\ -name *.bak -exec "rm {}"	(Lîschen aller *.bak-Dateien
				       auf Partition D:)

	seek d:\ *.* | backup	(Sichern aller Dateien von Partition D:
				 auf Diskette)

	seek e:\ *.* | xargs wc | pg  (Seitenweise Ausgabe der Anzahlen der
				 Zeilen, Zeichen und Worte aller Dateien
				 auf Partition E:)

	echo Auf A: sind `find A: -type x -print | wc -l` Dateien ausfÅhrbar.
				(ZÑhlen der ausfÅhrbaren Dateien auf A:)
	
	df -mn | xargs seek {}\ *.* | wc -l
				(ZÑhlen aller Dateien auf allen Laufwerken)

	upn 17 sqr pi * 	(Berechnen der OberflÑche eines Kreises mit
				 Radius 17)

	keydef F4 "dir *.c"	(Tastendefiniton: "dir *.c" wird auf die Taste
				 F4 gelegt)

	rm test.dat ; echo test.dat ist gelîscht
				(Verkettung von Anweisungen)

	format			(Formatieren der Diskette in Laufwerk A:)

	format -t40 -s10 B:	(Formatieren von Diskette B: mit 40 Tracks
				 und 10 Sektoren/Track)

	df(e:/newdf.sh) 	(Laden der Datei e:/newdf.sh und Abspeichern
				 als Shellfunktion, die anstelle des Komman-
				 dos df benutzt werden kann; in der Datei
				 kann das ursprÅngliche Kommando df unter
				 dem Namen !df benutzt werden)

        signum(e:signum2.prg)	(Laden und residenthalten von signum2.prg,
				 Aufruf Åber die Shellfunktion "signum")

	while [...]		(Schleifenbildung und Programmierung)
	do
	  ....
	  if [...]
	  then
	    ...
	  fi
	  break 		(Abbruch der while-Schleife)
	  continue		(Neuer Schleifendurchlauf)
	done


Weitere Beispiele: siehe commands.doc und tricks.doc


Dokumentation:

	readme			KurzeinfÅhrung
	release 		Versions-Identifikation der Shell
	okami.doc		Bedienung der Shell
	english.doc		Kurzfassung davon auf Englisch
	commands.doc		Bedienung der internen/externen Kommandos
	tricks.doc		Tips&Tricks zur Benutzung der Shell
	changes.doc		énderungen der Shell
	kompat.doc		KompatibilitÑt zu Ñlteren Shell-Versionen
	copying			Regelung des Kopierens der Shell
	msh.doc 		Benutzung der Micro-Shell
	autor.doc		Anschrift des Programmautors
